\documentclass[a4paper,12pt,twoside,leqno]{article}
\usepackage[paperwidth=210mm,paperheight=297mm,headheight=15.2pt,headsep=7.1mm,top=25mm,bottom=35mm,inner=30mm,outer=25mm,dvips]{geometry}

\usepackage{fancyhdr}
\usepackage{array}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{graphicx}
\fancyhead{}
\fancyfoot[EL]{\thepage}
\fancyfoot[OR]{\thepage}
\fancyfoot[C]{}
\catcode`\_=12
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\setcounter{page}{1}
\newenvironment{pascal}[3]{
\newcolumntype{q}{>{\leftskip\fill\hspace{0pt}}p{5mm}
<{\rightskip\fill\hspace{0pt}}}
\renewcommand{\arraystretch}{#1}
\setlength{\tabcolsep}{#2}
\begin{tabular}{*{#3}{q}}}{\end{tabular}}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[magyar]{babel}

\frenchspacing

\begin{document}
\section{Véges Determinisztikus autómaták}

\begin{center}
  Deterministic Finite Automaton, röviden DFA.
\end{center}


Leírása:
\\
Véges számú állapotból, és egy tranzíciós diagrammból áll, amelynek szakaszait úgynevezett input symbolumok jellemzik, amelyek ugyanabból a véges $\Sigma$ abc-ből vannak választva. \\
Minden egyes input szimbólum, pontosan 1 választ vált ki minden állapotból, az-az egy input szimbólum és állapothoz pontosan egy nyíl tartozik.
\vskip 0.3 true cm
Két kitüntetett állapot van: A kezdő állapot, jele : $q_{0}$ és a végállapot halmaza, amelynek a jele F. Ezek Start és Stop egység elemnek tekinthetők egy folyamat modellezés esetén.
\\ Start jelzi a folyamatábrán a draft lépést, ahol elindul a maga az üzleti folyamat. A végső lépés, az utolsó jóváhagyó (Approve lépés) pedig a végállapot, amely megfeltethető az F-nek.
\vskip 0.3 true cm
Egy véges determinisztikus autómatát a következőképpen definiálunk :  $A= (Q,\Sigma,\rho,q_{0},F)  $ ahol $Q$ az állapotok halmaza, $\Sigma$ a véges abc ,  $\Sigma \notin \emptyset $ továbbá $\rho$ a tranzíciós függvény, a  $q_{0}$ a kezdő állapot, $q_{0} \in Q $  $F$ a végállapot.
\\
Könnyen belátható, hogy $F \in Q $ illetve $ F \notin \emptyset$.
\\
A kimenő impulzus függ a bemeneti jelből, és attól, hogy éppen milyen állapotban van a neurom rendszer.
\\
Ez pontosan megfeleltethető annak, hogy egy folyamat esetén , melyik lépésben milyen input adatokat ad meg a felhasználó, mert a következő lépés ezen adatok alapján változhat. Egy példa esetén : A felhasználó 300.0000ft-ot állít be egy becsült költségnek, akkor oda egy igazgatói jóváhagyás szükséges, ellenkező eseben ez a lépés kihagyható. Az ilyen elágazásokat, és ciklusokat követően jutunk el a végállapotba, az inputoktól függően. Amely szintén az F. \\

\section{Egyszerű átmeneti rendszerek}
\begin{align*}
  A=(S,T,\alpha,\beta) & , ahol \\
  S \text{ az állapotok}& \text{ véges, vagy végtelen halmaza} \\
  T \text{ az átmentek} & \text{ véges, vagy végtelen halmaza} \\
  \alpha, \beta :  T \rightarrow S  , & \\
  \forall t \in T \text{-re }  \alpha(t) & \text{ a t keződpontja } \beta(t) \text{ a t átmenet végpontja .} 
\end{align*}
- Irányított gráf \\
-A csúcsok állapotokat reprezentálnak \\
- Az élek átmeneteket reprezentálnak \\
$\forall t\in T \text{-re } \alpha(t) \text{ csúcsból él vezet } \beta(t) \text{ csúcsba} $ \\
Az $A=(S,T,\alpha,\beta)$ átmeneti rendszerben $n>0$ hosszú útnak nevezünk egy olyan $t_{1},t_{2},\dots,t_{n}$ sorozatot, ha $\beta(t_{i}) = \alpha(t_{i+1})$ teljesül $\forall i\in \{ 1,\dots ,  n-1 \}$-re. \\
Utak konkatenációja, vagy összefűzése $c * c' = t_{1}t_{2}\dots t_{n} g_{1}\dots $ \\
Jó példa egy egyszerű átmeneti rendszerre például egy italautómata, amelybe egy rögzívett összeget dobva két gombot nyomhat meg a felhasználó. \\


\begin{center}
\bf{6. A Struktúrált programgráf és a nem determinisztikus autómata}
\end{center}
A struktúrált programozás olyan programozási elvek összessége, amelyek segítenek
megteremteni, hogy a program szövegszerkezete tükrözze a program végrehajtása
során követett vezérlési folyamatot.


A struktúrált programozás $3$ alapvető elemekből épül fel : Szekvencia , Ciklus , Elágazás . \\

Használt jelölés a szekvenciára : S(tevékenység1, tevékenység2 , $\dots$  , tevékenységn)\\
Ciklus formátuma : C(prédukátum, ciklusmag)\\
Az elágazásra : E(prédukátum,p,q)\\
Fontos jellemzőjük, hogy, minden építőelemnek csak egy belépési és egy kilépési pontja van.
A belépési pont a struktúa elején, a kilépés a végén van.
\\
\begin{center}
  Egy programot valódi programnak nevezünk, ha:
\end{center}

1. programgráfja véges számú nem zérus bemenő éllel és kimenő éllel rendelkezik, \\
2. programgráfjának csomópontjai predikátumok, függvények és gyűjtők, \\
3. programgráfjának minden csomópontján keresztül vezet legalább egy útvonal, \\
amely egy bemenő éllel és egy kimenő éllel rendelkezik ( a programgráf kezdő élétől \\
a kilépési élig vezet).

\begin{center}
 \bf{ Ez két kép helye, ahová a két folyamatábra fog kerülni, a modellizált folyamatokról (Road Transportatin Maintance, Demand) .}
\end{center}
A folyamat tervezésénél fontos szerepe van a strukturáltságnak, ellenkező esetben nagy problémák is adóthatnak, mint egy  végtelen ciklus, esetleg több input bemenet,vagy output.
Az első azért okozna problémát, mert a folyamat sosem érne véget, nem lenne befejezve. \\
 Ha több input bemenet lenne (több különböző draft page), egy folyamaton belül,  akkor az már egy más folyamathoz tartoznak, egy más igényléshez.
 \\
 A nagyobb és komplexebb folyamatokat, kisebb részekre is bonthatjuk, amelyre csak struktúrált programként van lehetőségünk. Ezt az eljárást
 a vezérlőgráf lebontásának nevezzük. \\
 Lépései :  a struktúrált alapszerkezetek valamelyikét egy függvény csomóponttal helyettesítjük, és ezt mindaddig folytatjuk, amíg ez lehetséges. Az egyetlen csomópontból álló gráfot egyetlen
éllel helyettesítjük.
\vskip 0.3 true cm
Megjegyzés \\
minden nem struktuált program átírható vele ekvivals strukturált program formályában. \\
Áttérésként a Véges Determinisztikus autómatákra, egy $a\in \Sigma$ betűhöz, és $q_{i}$ állapothoz, pontosan egy output (nyíl) tarotzik. \\
Nem determinisztikus autómata  (Nondeterminisztic Finite Automation) NFA esetén, viszon egy adott $q_{i}$ állapothoz és egy $a\in \Sigma$ jelhez több output is tartozhat, vagy egy sem.
\vskip 0.3 true cm
Tehát lehetséges olyan belső állapota, amiből a beolvasott szimbólum hatására több lehetséges állapot egyikébe mehet át.\\
Láthatjuk , hogy a véges állapotú autómaták megfeleltethetőek a modellezett folyamatoknak.
Egy strukturálatlan alapelemekből felépülő folyamat, megfelel egy Non determinisztikus autómatának.
A struktúrált elemekből felépülő modellezés pedig egy véges állapotú, determinisztikus autómatával.

Mint ahogy a Struktúrált programozánál is említettük, hogy bármely nem struktúrált program átírható, vele ekvivalens struktúrált programmá, ez szintén jellemző a véges állapotú, nondetermenisztikus autómatákra. \\
Ezt a tranzíciós függvény elkészítésével tudjuk megoldani, amelyben minden olyan állapot, ahonnan egy bizonyos beolvasott szóval több helyre tudunk eljutni, egy új állapotként felvesszük, majd rekurzívan tovább vizsgáljuk.

\begin{center}
  DFA és NFA ekvivalenciája
\end{center}
  Legyen adott egy $N=(Q,\Sigma,\rho , q_{0}, F) $ véges nondeterminisztikus autómata. Nyelve legyen $\alpha(n)$. n-ből kiindulva szerkezhetünk egy olyan A véges determinisztikus autómatát, amely ugyanazt az $\alpha(n)$ nyelvet fogadja el.\\
\begin{equation}
   A=(P(q),\Sigma,\rho^{'},[q_{0}],F' )
\end{equation}
Ahol Q a részhalmazok összessége, F' pedig a Q mindazon részhalmazai, amelyek legalább egy F beli állapotot tartalmaznak.(Végállapothoz vezetnek)

\begin{align*}
 && \rho'  \text{ így értelmezhetünk, minden } a\in\Sigma \\
 &&  \rho'([q_{1},q_{2},\dots,q_{n}],a) = \rho(q_{1},a) \cup \rho(q_{2},a) \cup \dots \cup \rho(q_{k},a)
\end{align*}

\begin{center}
  Egy A determinisztikus autómata és az N nondszereminisztikus autómata álltal elfogadott nyelv ugyanaz. $\alpha(A) = \alpha(N)$
\end{center}


\begin{center}
  Folyamatmodellezés részei
\end{center}

\section{Érzékenység vizsgálat}
  Mi történik, ha rosszul becsljük meg az erőforrásainkat? \\
 Mik számítanak lényeges paraméterek? \\
 Milyen erőforrásokat bővítsünk? (emberi vagy gépi)? \\
Mi történik, ha a modellparaméterek nem pontosak? becsléshiba , fejlődés

Az érzékenységvizsgálat során az optimális erőforrások paramétereinek a megvizsgálása, hogy azok megváltoztatása milyen hatással lenne az optimális megoldásra.\\
A szerkezet változatlan a marad.

\begin{center}
  Kétféle érzékenységvizsgálatot különböztetünk meg.
\end{center}
1.a jobboldali konstansokra az-az a kapacitásokra vontkozó érzékenység vizsgálat.
2. A $b_{i}$ paraméterek helyett a $b_{i} + \lambda$ szerepel a jobb (kapacitás)oldalon. \\ Az-Az $\lambda$ milyen értékek közé eshet?
Mennyivel tudjuk csökkenteni bizonyos erőforrásokat és mit érünk el vele?
Fontos  a célfüggvény együtthatók érzékenységi vizsgálata. \\
\begin{center}
  Egy álltalános képet, az n.-ik erőforrás vizsgálatához.
\end{center}
\begin{equation}
  \vec{b}+ \lambda \vec{u}_{n} \geq 0
\end{equation}

Érdemes mindíg azt növelni, ahol az árnyékár magasabb lehet, esetünk azt, ahol a legjelentősebb erőforrás növekedést tudjuk elérni.

\section{Mennyiségi analízis}

 Mennyi eset dolgozható fel egy órán belül? \\
 Mennyi extra erőforrásra van szükség? \\
 Mennyi az átlagos befejezési idő az egyes eseteknél?  \\
 Alternatív megvalósítások esetén melyik modell képes azonos idő alatt több eset kezelésére rövidebb idő alatt feldolgozni egy esetet kisebb várakozási időket generálni ? \\

 \section{Logikai Analízis}

 Történhet e deadlock a rendszerben?  \\
 Konkrét eset kezelhető-e sikeresen \\
 A folyamat végrehajtása során, minden eset végrehajtódik helyesen, és a végén terminál. \\
 Van e lehetőség két feladat tetszőleges sorrendben való végrehajtására.


 \section{Valószínűségi modell}
 A folyamat során bizonyos lépéseknél, elemzéseket végezve, az erőforrásokat különféleképpen is feloszthatjuk, hiszen lehet, hogy egy elágazás során az egyik részbe az esetek $90 \% $-ban lép be, így erre a részre nagyobb erőforrást teszünk, mint a maradék $10 \% $ részre.
 Az adatokat megvizsgálva következtethetünk, becsülhetünk.
 Egy  egy Diszkrét valószínűségi változó lesz, hiszen véges számú adatokat vizsgálunk.

\section{Petri hálók}
A Petri-hálókat az 1960-as években Carl Adam Petri határozta meg először. \\
A Petri háló (Petri net, PN) egy súlyozott, irányított élű páros gráf, melynek élei kétféle
csomópontot köthetnek össze: a körrel jelölt helyeket (places), illetve a téglalap-alakú állapotátmeneteket (transitions). \\
Formálisan a Petri hálók olyan <P,T,E,  $\delta $ , $m_{0}$> ötös, ahol
\begin{align*}
P & \text{ a } p_{i} \text{ helyek véges halmaza } \\
T & \text{ a } t_{i} \text{ tranzíciók véges halmaza } P \cap T = \emptyset \\
E & : (P \times T ) \cup (T \times P) \text{ a P-t és a T-t összekötő élek halmaza.}\\
\delta & \text{ a súlyfüggvény , }\qquad \delta:E\rightarrow N^{+} \\
& \text{Token eloszlás  }  m:P\rightarrow N   \text{ ami egy olyan függvény, } \\ & \text{  amely adott állapotban megadja a helyeken lévő tokenek számát} \\
&
\end{align*}
$m_{0}$ a kezdeti token eloszlás, az-az a hálózat kezdeti állapota. \\
A tranzíciót egy rövid vízszintes vonallal reprezentált csúcs.
\begin{align*}
  (p,t) \in & (P\times T) : \text{ p-ből t-be irányított él.} \\
  (t,p) \in & (T \times P) : \text{t-ből p-be irányított él.} \\
  m: P \rightarrow N & \text{ token eloszlás } m(p) \text{-t a p helyen} m(p)  \text{ darab korong reprezentálja az m állapotban.} \\
  e \in E & \text{ él címkéje a } w(e)
\end{align*}

Két élcsoportot definiálhatunk a Petri hálóba, a bemenő és a kimenző élek halmazát. Ez megfogalmazva az alábbiakat jelenti : \\

 \begin{align*}
   \text{Pre : } T \rightarrow \mu (P) & \text{ , ahol Pre(t) } = \{ p\in P \mid (p,t) \in E \} \text{ t őseinek vagy bemenő helyeinek halmaza}\\
   \text{Post: } T \rightarrow \mu(P) & \text{ ,ahol Post(t) } = \{ p\in P \mid (t,p) \in E \} \text{ t útódainak vagy kimenő helyeinek halmaza} \\
   \forall p \in P , \forall t \in T & \text{ esetén } \delta^{-}((p,t)) = \delta((p,t)) \text{ ha } (p,t) \in E \text{ egyébként } \delta^{-}((p,t)) = 0 \\
     & \delta^{-}((t,p)) = \delta((t,p)) \text{ ha } (t,p) \in E \text{ egyébként } \delta^{-}((t,p)) = 0
 \end{align*}
$\Delta $ súlyozott szomszédsági $ \mid T \mid \times \mid P \mid $ dimenziós mátrixok, ahol \\ 
$\Delta(t,p) = \delta^{+}((p,t))-\delta^{-}((t,p)) $. \\
A $\Delta^{-} $ és a $\Delta^{+}$ szintén $\mid T \mid \times \mid P \mid $ dimenziós mátrixok, ahol $\Delta^{-}(t,p) = \delta^{-}((p,t))$ illetve $ \Delta^{+}(t,p) = \delta^{+}((p,t)) $  \\

Egy tranzíció tüzelés akkor megengetedd, a t minden ősén van legalább $\delta((p,t))$ token, vagyis
\begin{equation*}
  \forall p \in Pre(t) : m(p) \geq \delta((p,t))
\end{equation*}
m állapotban véletlen módon választ egy engedélyezett tranzíciót, melyet tüzel. \\
m állapotban a t traníció tüzelésének eredménye az-az m' állapot , ahol 
\begin{equation*}
  \forall p \in P-re: m'(p) = m(p) - \delta^{-}((p,t)) + \delta^{+}((p,t))
\end{equation*}

A Petri hálók állapotváltozók státuszát reprezentálják. Az állapotokat a hely körében lévő fekete
pontok, az úgynevezett tokenek reprezentálják. A helyállapota a benne lévő tokenek számát
jelenti. A hálózat állapota az egyes helyállapotok összessége. Az állapotvektor a  $ \tau = \mid P \mid $ komponensű M token-eloszlású vektor, ahol a $p_{i}$ helyen található tokenek számát jelöli $m_{i}$ \\

A Petri hálók működése állapotátmenetekkel (trajektória) reprezentálható. Egy állapot
megváltozása a tranzíciók tüzelését jelenti:

A petri hálókat szokták alkalmazni az alábbi rendszerek modellezésében :
1.Nemdeterminisztikus \\
2.Párhuzamos \\
3.Elosztott\\
4.Konkurens\\
5.Asszinkron \\
A Petri-háló diszkrét elosztott rendszerek matematikai ábrázolása.\\
Az áttekinthetőség kedvéért ad egy grafikus reprezentációt, a precizitás és egyértelműség kedvéért pedig egy matematikai reprezentációt. \\
Az ábrázolás az egy időben lezajló események megjelenítésére alkalmas, az automataelmélet általánosításának tekinthető. \\
Előnye az autómatákhoz képest, hogy az ábrázolás az egy időben lezajló események megjelenítésére alkalmas, az automataelmélet általánosításának tekinthető. Előnye az autómatával szemben, hogy sokkal szemléletesebben fejezi ki a szinkronizációt, illetve kompakt módon fejezi ki az állapotot.
\vskip 0.3 true cm
Felépítése : irányított,súlyozott, páros gráf\\
Két típusú csomópontja lehet, egy kör és egy téglalap. A kör esetén egy hely, téglalap esetén egy trazíció.\\
Müködése:
Van egy állapotjelölő token, amely fekete pötty a hely körébe rajzolva.
A hely állapota pedig a bennelévő tokenek száma.\
Petri hálók jellemzői : \\
Azonnal tüzelések , Aszinkron tüzelések , nem determinisztikus , két tranzíció nem tüzel egyszerre, nem interpretált.\\
Bármely $e\in E$ élhez egy $ \delta : E  \rightarrow \Re^{+}  $ súlyfüggvényt is hozzárendelhetünk. \\
A minimális súlyú feszítőfa megtalálására legismertebb algoritmus a mohó algoritmus, amelyet az alábbi képpen definiálhatunk :\\
Egy $\Gamma = (V,E)$ összefüggő gráf. Legyen $\delta R \rightarrow \Re^{+}$ egy súlyfüggvény. A mohó algoritmus lépésében, kiválasztunk egy olyan $e_{1} \in E$ elemet, amelyre $\delta(e_{1}) \leq \delta(e)  $ ,  $\forall e \in E $ \\ Ha megvan kiválasztottuk az $e_{1} , e_{2}, \dots , e_{k}$  éleket, akkor az $e_{k+1}$-edik élet úgy választjuk, hogy ne alkosson kört
\begin{equation}
  e_{k+1} = { e\in E \setminus \{ {e_{1},e_{2},\dots,e_{k}} \} | \text{ az } \{ {e_{1},e_{2},\dots,e_{k},e} \} \text{ élek nem alkotnak kört} }
\end{equation}
illetve teljesül az is , hogy $ e_{k+1} < \forall \delta(e)$ \\

Könnyen belátható ez az algoritmus n-1 lépésből áll, ahol \\  $n=|V|, \text{ amely egy } \{ e_{1},e_{2},\dots,e_{n-1} \} $  élsorozatú feszítőfát eredményez.
\vskip 0.3 true cm
Egy
\begin{align*}
   \Gamma = (V,E)  \text{ gráf feszítőfájának nevezünk egy olyan} \Delta \text{ részgráfot amelyre } \\ \Delta = (V,E) \text{ és } \Delta \subset \Gamma \text{ és } \Delta \text{ fa}
\end{align*}
Az állapot megváltozása a tranzíciók "tüzelésével" történik.
Tüzelés végrehajtása az alábbiképpen zajlik :
Első lépésben megvizsgálja az engedélyezettséget, majd ezt követően a token elvétele következik a bemetni helyről, majd a token kirakása a kimeneti helyekre.\\
Ez egy olyan új állapotot eredményez, amelyben megváltozik a Token eloszlás vektor.
\\ Ezzel a témával kapcsolatosan hasznos információkat lehet találni az alábbi linken : \\
https://inf.mit.bme.hu/sites/default/files/materials/category/kateg%C3%B3ria/oktat%C3%A1s/msc-t%C3%A1rgyak/form%C3%A1lis-m%C3%B3dszerek/11/PN_alapfogalmak_kiterjesztesek.pdf
\vskip 0.3 true cm
Üzleti folyamatoknál gyakran megemlített a  {\bf workflow} (munkafolyamat) kifejezés, amelynek a jelentése:  Olyan tevékenységek sorozata, amelyeket az gépek vagy az emberek végrehajtanak, egy logikai terv szerint, valamilyen cél elérése érdekében. Magában foglalja az
üzleti folyamatok definiálását, végrehajtását és automatizálását, ahol a feladatok, információ vagy dokumentumok kerülnek átadásra egy résztvevőtől egy másikhoz, az eljárás szabályainak
megfelelően.
\vskip 0.3 true cm
A korábbi workflow rendszerek csak az üzleti folyamatok leképezését tették lehetővé vizualizációs eszközök segítségével. A BPM azóta sokat fejlődött és a támogató szoftvercsomagok sokkal több lehetőséget nyújtanak már, például a következőket:

 Mérések: Lehetőséget ad arra, hogy a folyamatokat valós időben átláthassuk. \\
 Modellezés: Workflow-k és feladatok tervezése, informatikai eszközökkel. \\
 Portálok: Egységes felhasználói felületek, webes felület végfelhasználók számára. \\
 Mobilitás :  Reszponzív felület, bármilyen képernyőn nyomon követhető. \\
 Metaadatok : Leírja a folyamatokhoz tartozó jellemezőket. \\
 Szimuláció: A folyamatmodell alkalmazásával különféle forgatókönyv és input adatok \\
szerinti vizsgálata a munkafolyamatnak.  \\
 Analízis: Elemzések, jelentések.  \\

 Egy olyan matematikai modell létrehozása a cél, amely az analízis szempontjából minden fontos jellemzőt magában
hordoz: \\
 formális szemantika \\
 nagy kifejezőerő \\
 könnyen értelmezhető, áttekinthető (grafikus) \\
 explicit állapot- és eseményreprezentáció \\

 Integráció: Emberek, információs rendszerek, szolgáltatások és egyéb folyamatok
összekapcsolása. \\
 Végrehajtás: Valós idejű igényekhez igazítva. \\
 \\
 Folyamatmenedzsment (workflow management, WF) alkalmazásoknak azon rendszereket
nevezzük, melyek a szervezeti tevékenységek folyamattá szervezését és a folyamat vezérlését
segítik. Tipikusan a következő szolgáltatásokat nyújtják: \\
 Munkafolyamatok tervezése;\\
 működési szabályok előírása;\\
 folyamatok vezérlése működés közben; \\
 folyamatok monitorozása, nyomon követése;
 kiértékelése.


\section{ Folyamat-gráf (Process Graph, P-Graph) }
Az egyik nagy előnye a folyamatok gráf alapú szemléltetésének, hogy a gráfelmélet eredmények és algoritmusok alkalmazhatóak  a vizsgálat során. \\
 A folyamat-gráf, egy speciális irányított páros gráf optimalizálási feladatok hatékony megoldásához, vagy épp
workflow modellezéshez.  \\
BPMN (Business Process Modelling Notation ) fogalma:
A BPMN szabványosított grafikus jelölési mód, mely lehetőséget ad az üzleti élet
szereplőinek, hogy folyamataikat standardizált formában tehessék közzé.

 Egy  UML-hez hasonló workflow leíró eszköz, amely könnyen értelmezhető grafikus
jelölésrendszer biztosít az üzleti folyamatok ábrázolásához.  A grafikus jelölés
segítségével kiküszöbölhetőek a résztvevők között felmerülő kommunikáció nehézségek. Szabványos eszköznek számít az
üzleti folyamatok, valamint a webes szolgáltatások modellezéséhez. \\
Két fő célja van :
Első,  hogy az XML alapú nyelvek, amiket az üzleti folyamatok végrehajtására terveznek, azok vizualizálhatók legyenek egy szabványos jelölőrendszerrel. \\
Második, hogy egy olyan üzleti folyamat jelölőrendszer tudjon biztosítani, ami bármely stakeholder számára
értelmezhető, az üzleti elemzőktől kezdve a szoftverfejlesztőkön át a vállalati vezetőkig, ezáltal
a kommunikációt nagyban megkönnyítve.\\

A BPMN folyamat-orientált megközelítéssel dolgozik. Három alapobjektumát a tevékenységek, események , és az átjáró jelentik. \\

A BPMN üzleti folyamat modellező standarddá vált. Népszerűségét könnyű elsajátíthatóságának és értelmezhetőségének köszönheti.



Egy BPMN folyamatábra leképezhető P-gráffá is.




\section{Folyamatszintézis}
A nagy szoftverek kisebb részekből állnak. A kisebb részek szintén úgy épülnek fel, hogy mégkisebb programrészeket használnak fel. Egy-egy programrészről tudjuk, hogy mely adathalmazt és objektum összességet használja és ezekből milyen adatokat állít elő.\\
A tervezés fontos része ezen komponensek összeillesztése, illetve összehozása.
\vskip 0.3 true cm
A komplex tudás, a szakértelem úgy jön létre, hogy alapképességekből és megszerzett isme-retekből újabb, összetettebb tárgyi tudáselemek keletkeznek.
\subsection{Struktúrális modell}
Jelölje $\phi(H)$ egy tetszőleges H halmaz nem üres részhalmazát. Legyen M és O $ \subset \phi^{'}(M) \times \phi^{'}(M) $ véges, nem üres diszjunkt halmazok.
Az M elemei az anyagok, míg az O elemei a műveleti egységek, melyek segítségével bizonyos bemenő anyagokból nyerünk előírt módon egy kimeneti anyaghalmazt.\\

Az (M,O) párhoz egyértelműen hozzárendelhető egy gráf, amit folyamatgráfnak nevezünk: PG(M,O) = $M\cup O , A_{1} \cup A_{2} $
ahol az élhalmaz kétféle típusból áll :
\begin{align*}
A_{1} & = \{ (X,Y):Y = (\alpha,\beta) \in O \text{ és } X \in \alpha \}\\
A_{2} & =  \{ (Y,X):Y = (\alpha,\beta) \in O \text{ és } X \in \beta \}  \\
\\
(a+b)^3&= a^3+3a^2b+3ab^2+b^3.
\end{align*}

Egy $(V',E')$ gráf egy PG(M,O) folyamatgráf részgráfja, ha :

\begin{align*}
V' & = M' \cup O' , M' \subseteq M  , O'\subseteq O\\
O' & \subseteq  \phi '(M') \times \phi ' (M')  \\
\\
E'&= A_{1}' \cup A_{2}' \text{ ahol }
\end{align*}
$A_{1}  = \{ (X,Y):Y = (\alpha,\beta) \in O \text{ és } X \in \alpha \} \text{ és }
A_{2}  =  \{ (Y,X):Y = (\alpha,\beta) \in O \text{ és } X \in \beta \}
$

\vskip 0.3 true cm


\newpage
\section{Folyamatmodellezés}
A modell, a való világ egy részének egyszerűsített példánya.


A modellezés célja,az  hogy felmérjük, majd  elemezhessük és javíthassuk a
folyamatainkat.Esetünkben azt célszerű vizsgálni, milyen jóváhagyási lépések szükségesek , és melyek azok amelyek elhagyhatóak, redundánsak. Az elmezés során több szempontot érdemes szemügyre venni. Például felhasználók kérését, az erőforrások kezelését.  A folyamatmodellek különböző információkat hordozhatnak és változó lehet a befogadó fél is, így nem mindegy, hogy milyen szemszögéből nézve készítjük el őket. Tehát a különböző nagy részlegeknek más-más célja lesz az adott folyamattal, különböző megjelenési formákat kell biztosítani, más változókkal, mezőkkel , adatbázissal, és erőforásokkal. A folyamatmodellek alapvetően két csoportra bonthatóak. Léteznek As-Is
modellek, amik a jelenlegi helyzetet mutatják be, és To-Be modellek, amik a kívánt
szituáció ábrázolását takarják.  \\
A folyamatok leírására több lehetőség van. Legtöbbször ezek
kombinációját használják a felelős személyek, ahelyett, hogy egyetlen egyhez
ragaszkodnának. Készülhet szöveges folyamatleírás vagy táblázatos leírás is, de a
legcélravezetőbb a grafikus, modell-orientált leírás, amely segítségével sokkal
egyértelműbben, és átláthatóbban ábrázolhatjuk az adott folyamatokat. A Bpm rendszer grafikus ábrázolást használ, hiszen folyamatábrákat használ, a jó áttekinthetőség érdekében. \\

Több különböző szoftvert vehetünk igénybe a grafikus ábrázolás elkészítéséhez, amelyek megkönnyítik az elkészítést, de ebből adódóan egy hátrányt is
magában hordoz a módszer, mégpedig azt, hogy a többféle ábrázolási módból adódóan,
nehezen értelmezhető modellek jöhetnek létre. Ennek kiküszöbölésére azonban már
bevezetésre kerültek olyan modellező nyelvek, szoftverek, melyek egységesítik az
ábrázolás módját, ilyenek például az UML szabvány.
Az UML szabványos,  általános célú modellező nyelv, üzleti elemzők, rendszertervezők, szoftvermérnökök számára.
Jelentése:  (Unified Modeling Language)
 Segítségével tervezni  illetve dokumentálni lehet a szoftvereket. Az UML-ben modellek és diagramok adhatók meg, különböző nézetekben.
Az üzleti feladatok nem csupán a szereplőkkel lehetnek kapcsolatban, hanem más feladatokkal is kapcsolatban állhatnak. Gyakran állnak elő összefüggések különféle üzleti részfolyamatok illetve használati esetek között. Az UML két lehetséges függőségi kapcsolatot definiál a használati esetek között, ezek a beillesztés és a kiterjesztés.
Az UML a jelöléseknek gazdag választékát kínálja, mely segítségével a szoftverfejlesztés összesfázisamodellezhető. \\

Az üzleti folyamatok modellezésével az üzleti stratégia és az informatikai
rendszerek között olyan kapcsolat hozható létre, ami nagyban hozzájárulhat üzleti
értékünk növeléséhez.

\section{Folyamatmodellezés és szimuláció}

A sorbanállási modell a hétköznapi életben is előforduló egyik kellemetlen jelenség a
várakozás vizsgálatával foglalkozik. Definíció szerint a sorbanállás-elmélet különböző
folyamatok eseményeivel kapcsolatos várakozási sorokat, sorbanállási időket a
kiszolgálásra, és ezek összefüggéseit tárgyalja az alkalmazott matematikai eszközeivel. \\

A folyamat során várakozó sor keletkezhet, ha a kiszolgáló egységekbe történő áramlás
időköze, és a kiszolgálás időtartama szabálytalan. Sorbanállás keletkezhet akkor is a
beáramlás időköze kisebb, mint a kiszolgálás időtartama, ekkor a tároló térben a beáramló
várakozó anyagmennyiség, azaz várakozó sor folyamatosan növekszik. \\

A gyakorlati életben a beérkezés időköze, és a kiszolgálás ideje nem meghatározott, hanem
valószínűségi változó. Ekkor sztochasztikus folyamatról beszélünk, amelynek megoldása
bizonyos feltételek mellett analitikusan végrehajtható. A várakozó sorba időegység alatt
beérkező egységek száma, mint valószínűségi változó leggyakrabban Poisson féle eloszlást
követ, amely egy diszkrét valószínűségi változó, amelynek a definíciója:  \\
Legyen $\lambda > 0$ egy rögzített valós szám. Azt mondjuk, hogy a $\xi$ valószínűségi változó Poisson
eloszlású $\lambda$ paraméterrel, ha eloszlása:
\begin{equation}
  p_{k} = P(\xi = k) = { {\lambda^{k}}\over{k!} } * e^{-\lambda}
\end{equation}

A $\xi$ várható értéke és szórásnégyzete $E(\xi) = D^{2}(\xi)=\lambda$ . \\
A várható érték képlete diszkrét esetben :
\begin{align*}
  \sum_{i=1}^{n} (x_{i}-a)*p_{i} & =0 \\
     \sum_{i=1}^{n} x_{i}*p_{i} - a* \sum_{i=1}^{n} p_{i} & =0 \\
     a = { \sum_{i=1}^{n} x_{i}*p_{i} \over{\sum_{i=1}^{n} p_{i}} } \\
     \sum_{i=1}^{n} p_{i} = 1 \text{ ebből következik } a & = \sum_{i=1}^{n} x_{i}*p_{i}
\end{align*}
Fontos megjegyezni, az $x_{1}, x_{2}, \dots $ hogy $\exists E(\xi) = \sum_{i=1}^{\infty} x_{i}* p_{i} $ , ha $\sum_{i=1}^{\infty} \mid x_{i} * p_{i} \mid < + \infty $ .

A poisson eloszlás várható értékének a bizonyítása :

\begin{align*}
  E(\xi) = \sum_{k=0}^{\infty} x_{k} * p(k,\lambda)  = \sum_{k=0}^{\infty} k {\lambda^{k} \over{k!}}* e^{-\lambda} = \\
  \sum_{k=1}^{\infty} { \lambda^{k} \over{ (k-1)! } }* e^{-\lambda} = \lambda* e^{-\lambda} \sum_{k=1}^{\infty} { \lambda^{k-1} \over{ (k-1)!}}
  = & \lambda* e^{-\lambda}* e^{\lambda} = \lambda
\end{align*}

A poisson eloszlás szórás négyzete $ D^{2}(\xi) = \lambda $ bizonyításához felhasználjuk a $D^{2}(\xi) = E(\xi^{2})-E^{2}(\xi)$ összefüggést. (Ez a második centrális momentum alapján könnyen igazolható, hiszen :\\
$ E( (\xi - E(\xi)^2 ) = E(\xi^2 - 2\xi E(\xi) + E^2(\xi) ) $ , itt a véges additivátást követően az alábbi képet adódik : \\
$ E(\xi^2) - 2*E(\xi)*E(\xi) + E^2(\xi) =  E(\xi^{2})-E^{2}(\xi) $
\\ Ezeket az összefüggéseket felhasználva belátható, hogy :

\begin{align*}
  E(\xi^2)   = \sum_{k=0}^{} k^{2}* { \lambda^k \over{k!} }  * e^{-\lambda}  = \sum_{k=1}^{\infty} [(k-1)+1]  \\ { \lambda^k \over{(k-1)!} } * e^{-\lambda}  = \sum_{k=2}^{\infty} (k-1){ \lambda^k \over{ (k-1) !} } * e^{-\lambda}   + \\ \sum_{k=1}^{\infty} { \lambda^k \over{(k-1)!} } * e^{-\lambda}   =  \lambda^2 e^{-\lambda} \sum_{k=2}^{\infty} { \lambda^{k-2} \over{ (k-2) ! } } + \lambda e^{-\lambda} \sum_{k(1}^{\infty} { \lambda^{k-1} \over{(k-1)!} } = \lambda^2 + \lambda
 \end{align*}
A képletbe helyettesítve $ D^{2} (\xi) =  E(\xi^{2})-E^{2}(\xi) =(\lambda^2 + \lambda) - \lambda^2 = \lambda $
\noindent

\begin{center}
  A poisson eloszlás és exponenciális eloszlás kapcsolata.
\end{center}

Ha időegység alatt bekövetkező események száma Poisson eloszlású
valószínűségi változó, akkor két egymást követő bekövetkezés között eltelt idő exponenciális eloszlású ugyanazzal a $\lambda$ paraméterrel. \\
Az exponenciális eloszlás egy folytonos valószinűségi változó. \\
Legyen a $\xi$ abszolút folytonos valószínűségi változó sűrűságfüggvénye $f_{\xi}(x)$. Ekkor a $\xi$ várható értéke
\begin{equation*}
  E(\xi) = \int_{-\infty}^{\infty} x f_{\xi}(x) dx
\end{equation*}
ha az integrál konvergens, az-az $\int_{-\infty}^{\infty} \mid x \mid f_{\xi}(x) < \infty $
\\Az $F(x) = P(\xi < x) $ formulával meghatározott valós függvényt a $\xi$ valószínűségi változó eloszlásfüggvényének nevezzük. \\

A sűrűségfüggvény definíciója : \\
Ha létezik egy $f$ nemnegatív valós függvény, amelyre
\begin{equation*}
  F(x) = \int_{-\infty}^{x} f(t) dt \qquad \forall x \in \Re
\end{equation*}
akkor az $f$ az $F$ eloszlásfüggvényhez tartozó sűrűségfüggvény. \\

A $\xi$ valószínűségi változót $\lambda$ paraméterű exponenciális eloszlásúnak nevezzük, ha eloszlásfüggvénye:
\begin{align*}
  F(x) & = 0 ,\qquad x \leq 0 \\
  F(x) & = 1-e^{-\lambda x} \qquad x> 0
\end{align*}
Az $f(x) = F'(x)$ definíció alapján, az exponenciális eloszlás sűrűségfüggvénye :
\begin{align*}
    f(x) & = 0 ,\qquad x \leq 0 \\
  f(x) & = \lambda e^{-\lambda x} \qquad x> 0
\end{align*}

A folyamatos valószínűségi változó várható értéke az $E(\xi) = \int_{-\infty}^{\infty} x f(\xi) dx $ alapján :
\begin{align*}
    f_{\xi}(x) & = \lambda e^{-\lambda x } , \\
 \int_{-\infty}^{\infty} f_{xi} (x) & = 0 \\
 E(\xi) = & \int_{-\infty}^{\infty} x \lambda e^{-\lambda x} dx = \\
 & x e^{-\lambda x} - \int_{0}^{\infty} 1 e^{-\lambda x} dx =  \\
\end{align*}
Ha megvizsgáljuk az integrál előtti részt, $x=0$ és $ x=\infty$ értéket behelyettesítve, akkor annak az értéke nulla.\\
Marad $-\int_{0}^{\infty} 1 e^{-\lambda x} dx$ rész. \\

\begin{equation*}
  -{1\over{\lambda}} * \int_{0}^{\infty} \lambda e^{-\lambda x} \text{ami a sűrűségfüggvény}
\end{equation*}


Az alap definíció alapján $\int_{\infty}^{\infty} f_{xi}(x) dx = 1 $ , ebből kifolyólag $E(\xi) = {1\over{\lambda}} $ \\

A   $ D(\xi) = \sqrt{E(\xi ^2) - E^{2}(\xi)}$ szórás képletét felhasználva, ahol $E^{2}(\xi) = {1\over{\lambda^2}} $ ,  az alábbi képlet adódik :

\begin{align*}
& E(\xi^{2}) = \int_{-\infty}^{\infty} x^{2} f_{\xi}(x) dx = x^{2}* e^{-\lambda x } - \int_{0}^{\infty} 2x e^{-\lambda x} dx ={ 2 e^{-\lambda x} \over{\lambda^2} } = { 2 \over{\lambda^2} } \\
& = \sqrt{ {2 \over{\lambda^2} }  - {1 \over{\lambda^2} } } =  {1 \over{\lambda} }
\end{align*}
Így a $D^{2}(\xi) = {1\over{\lambda^2}}$ \\
A bizonyítás a karakterisztikus függvény segítségével is levezethető.


\section{Egyéb folyamatleíró nyelvek}
{\bf IDEF} diagramok : Az Integrated Definition (IDEF) folyamatleíró nyelvet elsősorban folyamatok
fejlesztéséhez, integrációjához, tervezéséhez és rendszerelemzéshez kapcsolódó
tevékenységek leírására használják. \\
 A modellkészítés első lépése, mivel a
rendszer alapvető funkciói, tevékenységei közötti kapcsolati feltételeket állapítja meg.
Ezenfelül részletes leírást ad a rendszer folyamatairól, tevékenységeiről.\\
Részei: \\
IDEF0  : Funkció modellezés \\
IDEF1  : Információs modellezés \\
IDEF1X  : Adatmodellezés  \\
IDEF2  : Szimulációs modelltervezés \\
IDEF3  : Folyamatleírás rögzítése  \\
IDEF4  : Objektum-orientált tervezés - Az objektumorientált programozás, karbantarthatóság és kód újrafelhasználhatóság megvalósítható a hagyományos adatfeldolgozó alkalmazásokban. \\
IDEF5  : Ontológia leírása \\
IDEF6  : Tervezési indoklás rögzítése  \\
IDEF7: Információs rendszerek ellenőrzése \\
IDEF8  : Felhasználói felület modellezése- az ember és a rendszer közötti interakció tervezésének integrált meghatározása szolgál. \\
IDEF9  : Üzleti kényszer felfedezése\\
IDEF10: Megvalósítási architektúra modellezése
IDEF11: Információs tárgyak modellezése \\
IDEF12: Szervezeti modellezés \\
IDEF13: Három séma leképezési tervezés -  az üzleti kényszerfelfedezés integrált meghatározása arra szolgál, hogy segítsen az üzleti rendszerbeli korlátok felderítésében és elemzésében. \\
IDEF14  : Hálózat tervezése - a számítógépes és kommunikációs hálózatok modellezését és tervezését célozza \\

Az {\bf EPC } ( Event Driven Process Chain ) események és funkciók irányított gráfja . \\ Különböző logikai kapcsolatok
hozhatók létre benne, melynek révén alkalmas alternatív vagy párhuzamos lefutású
folyamatok modellezésére. Ezekhez olyan logikai operátorokat használ, mint az OR, AND
és a XOR. \\
XOR, vagy másnéven kizáró vagy az alábbi formátummal adható meg : $ ( \bar{x} \land y  ) \lor ( x \land \bar{y} )$ \\
 Az EPC felhasználható a vállalati erőforrás-tervezés végrehajtásának konfigurálására és az üzleti folyamatok fejlesztésére. \\
Irányított gráf definíciója : \\
A $G=(V,E)$ rendezett párt irányított gráfnak (digráfnak) nevezzük. A
rendezett pár elemeire tett kikötések: $V$ véges halmaz, a $G$ -beli csúcsok halmaza.
$ E $ bináris reláció a halmazon, az élek halmaza. \\
$E=\{ (u,v) \text{ rendezett pár } u\in V , v \in V \} \subset V \times V \text{ hurok megengedett.} $ \\
Korábban a szomszédsági mátrix-t megemlítve az alábbi definíciót fogalmazhatjuk meg vele kapcsolatosan : \\
Egy páros gráf A szomszédsági mátrixa, ha a páros gráf partíciói r, illetve s csúcsból állnak, a következő alakban felírható: \\
\begin{equation*}
A=\left ( \begin{matrix}
0_{r,r} & B  \\
B^{T} & 0_{s,s}  \\
\end{matrix} \right )
\label{eq:elso}
\end{equation*}
ahol B egy $r \times s $ mátrix, $0_{r,r}$ és $0_{s,s}$ pedig $ r \times r$, illetve $ s \times s $méretű $0$-kból álló mátrixokat jelölnek.

{\bf YAWL } (Yet Another Workflow Language) Kezdetben csupán a munkafolyamatokban előforduló tevékenységekre koncentrált, de mára
már munkafolyamat leírásának teljes eszköztárát támogatja a folyamateditortól a
folyamatmotoron át a modellező eszközig. A nyelvet egy olyan szoftverrendszer támogatja, amely egy végrehajtó motort, egy grafikus szerkesztőt és egy munkalista kezelőt tartalmaz. \\
A nyelvet és támogató rendszerét eredetileg az Eindhoveni Műszaki Egyetem és a Queenslandi Műszaki Egyetem kutatói fejlesztették ki .\\
Főbb jellemzői: \\
A munkafolyamatok átfogó támogatása. \\
A fejlett erőforrás-elosztási részek támogatása, beleértve a négy szem elvét és a láncolt végrehajtást. \\
A munkafolyamat-modellek dinamikus adaptálásának támogatása. \\
Kifinomult munkafolyamat-modell érvényesítési funkciók (Holtpont észlelés a tervezési időben) \\


{\bf BPD} (Business Process Diagram)
Irányított folyamatok ír le BPMN elemekkel. Alkalmas vállalati tevékenységek leírására. A
folyamatok történhetnek szervezetek között (kollaboráció), szervezeti szinten, vagy kisebb
egységen belül, ezeket munkafolyamatoknak is hívjuk. A különböző szintű BPD
diagramokat érdemes külön ábrázolni, mert a diagram nehezen érhetővé válhat. \\


{\bf A BPEL} olyan szabványos leíró nyelv, amely üzleti partnerek folyamatainak leírásara
alkalmas, és webszolgátatáson keresztül segíti a folyamatok összehangolását, végrehajtását.
Megjelenítési nyelve az XML, de grafikus ábrázolást nem tesz lehetővé és nem rendelkezik
szabványosított folyamattervezési metodikával. Az egyes aktivitások végrehajtása egy
külső, kiegészítő nyelven elkészített parancs meghívásával jár, ami leggyakrabban Java.\\

{\bf Az XPDL } (XML Process Definition Language) a WfMC (Wokflow Management Coalition)
által szabványosított leírónyelv. Az XPDL egy olyan XML sémát definiál, ami alkalmas a
különböző leíró és modellezési eszközök közötti információcserére. Fontos kiemelni, hogy
az XPDL a folyamat leírása mellett a folyamat végrehajtására is tartalmaz információkat.
Ezzel szemben a BPEL csak a végrehajtásra koncentrál.

{\bf A SysML} egy általános célú leíró nyelv mérnöki alkalmazásokra kifejlesztve. Specifikációk,
analízis, tervezés, felülvizsgálat és jóváhagyás területén nyújt támogatást. A SysML
tulajdonképpen az UML kiterjesztett változata. \\

A folyamat, algoritmusok leírását a mérnöki/műszaki tudományok területén kezdték
formalizálni az 1930-as években.


\section{Folyamatok az iparban}

Minden nagyvállalatban egyszerre akár több üzleti, logisztikai folyamat zajlik. Ezeket a folyamatokat többféleképpen nyomon lehet követni. \\

% TODO: Leírni, hogy a megközelítési módok miben különbözhetnek.
A legtöbb nagy cég a BPM (Business Process Management) platformot használja a feladatok nyomonkövetésére, menedzselésére.
A rendszerben megtalálható Process Designer program segítségével minden folyamathoz tartozik egy folyamatábra.
\\A folyamatábrán az elvégzett feladatokat zölddel, az aktuális lépést pirossal, a következő lépéseket pedig szürkével jelöli.
A rendszer listázza az összes meglévő folyamatot, amelyet el lehet indítani egy cégnél.
A folyamatábrán az egyes lépésekre kattintva további részletes információkat tekinthetünk meg, mint a view pagen használt mezőket,
a mögötte lévő adatbázis mezőket, a felhasznált ajax service-eket. Az Ajax Service implementációit lehet megtekinteni.
Az egyes elágazásokban lévő döntési változókat lehet megtekinteni stb. (Elég részletes program)

Ez a rendszer fizetős, nem érhetőek el ezek a szolgáltatások Lokális gépről.
A rendszer mivel elég széles körü, így eléggé rugalmatlan is, mivel ha hirtelen egy új üzleti folyamatra lenne szüksége a cégnek, akkor annak az
elkészítése akár több hetet is igénybe vehet.

Hogy példát említsek üzleti folyamatokra:
Egy autógyárban lehet akár egy gyártási folyamat, akár egy karbantartási folyamat, vagy valamilyen igénylési folyamat, amelyek több lépésekben folynak le.
Több jogosultsági szintek vannak egy ilyen folyamatnál, amelyeket megkell különböztetni. Mikor, melyik lépésnél ki a jóváhagyó stb.
Ezeket a folyamatokat valahol nyilván kell tartani, kezelni kell őket.

Folyamatok előfordulhatnak ipait vállalatoknál (Bosch, Joyson, BorsodChem), egyéb logisztikával kapcsolatos cégeknél, különböző kereskedelmi szervezeteknél.
A legtöbb nagyipari vállalat az IBM-BPM platformot használja.
A folyamatok menedzseléséhez, követéséhez hozzátartozik az SAP, amely egy vállalatirányítási rendszer, sokszor indítanak el SAP-ból egy folyamatot.
Ahhoz, hogy egy folyamatot elkészítsünk, amely sap-ból indul, szükséges a Process Designerben ezt Ajax Service formájában definiálni, és Postman segítségével teszteleni,
amely a legtöbb esetben egy folyamat azonosítót és egy lépés azonosítót ad vissza. Ezeket megkeresve tudjuk az adatbázisba megtekinteni , felhasználni, és a formon kiolvasni az adatokat.


-Egy karbantartási folyamat esetén , egy nagyobb cégnél 5 lépésben folyik le:
\\-Az igénylő kitölti a formot, ahol megadja a gépjármű adatait, a probléma pontos leírását. Továbbítja a folyamatot.
\\-Az első jóváhagyó (SupervisorApprove) ez a formot megkapja, ír hozzá egy megjegyzést, majd eztkövetően a folyamat továbbmegy a coordinátorhoz,
amely meghatározza a probléma leírása alapján,a költségeket, a javítás várható idő intervallumát, a helyet stb.
\\-Amennyiben költség szintje meghaladja az adott értéket, akkor a folyamat folytatásához a Director jóváhagyása kell. Ő dönti el hogy vissza reject-eli, vagy továbbítja a folyamatot.
\\-A feladat visszakerül az igénylőhöz



\section{Az alkalmazás bemutatása}

Az fentebb említett problémára, egy olyan vállalati folyamatmodellezési rendszer készítése, amelyben végig lehet követni az elindított folyamatokat, lehetőség lesz új folyamatokat lehet elindítani, az elindított folyamatok állapotát megtekinteni, a meglévő folyamatokat nyomon követni, ezzel megkönnyítve a cég üzleti folyamatainak menedzselését.

A folyamatnak egy aktuális lépésében lehetőség van annak a továbbítása, amellyel a következő illetékes személyhez fog kerülni a feladat. (Ez akár egy feltételes elágazás is lehet, valamilyen megadott paraméter alapján).

Lehetőség van elutasításra, ha valamilyen hiba lépett fel, akár egy nem megfelelő adat, amellyel az előző személyhez kerül a feladat elküldése.

A folyamatot a vezetőknek lesz jogosultsága elindítani, és a vállalat alkalmazottai közül lehet majd választani, hogy kinek szeretné kiadni a feladatot. A folyamat elindításához szükséges kitölteni a feladat pontos leírását, az elvégzési határidőt, illetve kiválasztani az illetékes személyt.

Az alkalmazásban több különböző \textit{viewpage} lesz megvalósítva.

% TODO: Az előbbit valahogy magyarosabban is ki lehetne fejezni.

%Lesz egy bejelentkezési felület, amelybe az alkalmazottak felhasználónevét és a jelszavát kell megadni a belépéshez.  Különböző jogosultsági szintek lesznek megvalósítva.
%(Ezekről a későbbiekben még részletesebben szó lesz.)

%A belépést követően a vezetőségnek, és az alkalmazottaknak is másféle weboldal fog megjelenni.

%Felugró ablakban fog megjelenni a feladat elindítása.                                                              (Egyenlőre kikommentezem akkor a törölhető részletet! )

% TODO: Ez olyan részlet, amit itt vagy konkrétan, képernyőképekkel kellene bemutatni, vagy nem kell ilyen formában említeni.


Az alkalmazott a folyamatokat, amiket neki osztottak ki, megtekintheti egy erre specializált menüpontban, itt kiválasztva a folyamatot, megtekintheti a hozzá tartozó információkat.

\section{Működése}

A felhasználó képes lesz arra, hogy a kapott feladatot továbbítsa, esetleg vissza küldje attól a felhasználótól (Vezetőségtől), akitől megkapta.

Egy feladat az alábbi információkat tartalmazza:
\begin{enumerate}
\item feladat pontos leírása,
\item elvégzési határidő,
\item kitől kapta (Név + Részleg),
\item mikor kapta .
\end{enumerate}
Minden Részlegnek lesz egy vezetője, aki képes lesz listázni a részlegen lévő alkalmazottakat, itt megtudja tekinteni ki lenne aktuálisan megfelelő a feladat elvégzésére. Az egyes alkalmazottakra kattintva, lehetőség lesz az alkalmazott adatainak részleges megjelentésére. Ez a mód csak vezetőként belépve lesz elérhető. Itt tudunk majd egy feladatot elindítani.


\section{Megvalósítás}
Az adatok tárolása a \textit{Microsoft SQL Server}-ben történik, itt egy \textit{CompanyDB}-ben létre lesz hozva több különböző táblázat, mint például Employee, Leader, Task, illetve Részleg. \\
% TODO: Az előbbihez nem feltétlenül kell példa, hogy ha utána egyébként is teljes részletességgel be lesz majd mutatva.
% TODO: Minden táblának és mezőnek kellene név. A részleg esetében példának beírtam, hogy a mező nevét és a típusát hogy lehet például megadni.

A részleg táblázatban
\begin{itemize}
\item \texttt{id}: A részleghez tartozó egyedi azonosító. (Egész érték)
\item \texttt{name}: A részleg pontos megnevezése, amelyhez az Id tartozik. (Szöveg)
\end{itemize}

A Task táblához fog az alábbi rekordok fognak tartozni:
\begin{itemize}
\item Egy részleg vezetőéhez tartozó Id, hogy melyik vezető indította el a task-ot.
\item Egy időpont, hogy mikor lett elindítva a feladat.
\item Feladat pontos leírása, Description rész.
\item Illetve egy határidő rekort.
\end{itemize}

Employee Táblázatban:
\begin{itemize}
\item Id, Az alkalmazott egyedi azonosítója.
\item Az alkalmazott pontos neve. (Vezetéknév + Keresztnév)
\item Életkora
\item Neme
\item Lakcíme
\item Telefonszáma
\item Email címe
\item poziciója
\item A részleg Id-ja, hogy melyik részlegen dolgozik az adott alkalmazott.
\item A részleg neve, amelyhez a megadott Id tartozik.
\end{itemize}

Leader Táblázatban:
\begin{itemize}
\item Leader pontos neve, ez tartalmazza a keretnevét, illetve a vezetéknevét. Összetett rekord lesz.
\item Részleg kódja, amely részlegen az adott személy vezető.
\item Elérhetősége , amelye egy email cím formát fog jelenteni, validálással megfeleltve.
\item Egy dátum mező, hogy pontosan mióta vezető az adott részlegen.
\end{itemize}

Egy Department tartalmazó táblázat:
\begin{itemize}
\item Id, A részleg egyedi azonosítószáma (Elsődleges kulcs)
\item Name, a részleg pontos megnevezése
\end{itemize}

Egy Task-ot tartalmazó táblázat:
\begin{itemize}
\item Egy Id, amely a task-ot azonosítja. Ki az elküldő, a feladatot ki kapja majd meg.
\item Description, a feladat pontos leírása.
\item Kezdő idő , amikor a feladat létre lett hozva.
\item Befejezési idő, hogy a feladat meddig végezhető el.
\end{itemize}
Későbbiekben két folyamatról lesz szó, amelyet reprezentálni fogunk, a következő kibővített Er modellen ez látható : \\
\section{IDE MAJD ER MODEL KÉP JÖN}
\begin{figure}[h]
\centering
\includegraphics[scale=0.3]{images/ER.png}
\caption{Minta kép}
\label{fig:minta}
\end{figure}

A kapcsolatok . ábrán látható séma szerint lettek kialakítva. \\

Az adatbázisban a kapcsolatok kialakítása, és a feltételekhez kötött listázások .net framework egyik sajátosággával, az Entity Frameworkkel lesz kialakítva, Visual Studióban implementálva, asp.net Core-t használva. \\

\section{Funkciók}

Az applikációban megvalósításra kerülnek az alábbiak:
\begin{enumerate}
\item Felhasználók kilistázása részlegek szerint, amelyre vezetőknek van jogosultsága.  Ez egy különálló view page-n fog megjelnni.
\item Lehetőségük lesz egy adott alkalmazott megkeresésére, majd az alkalmazattok adatainak részleges lekérésére.
\item Az olyan kiosztott feladatokat lehet kilistázni, amelyeket az aktuális vezető indított el . A feladatnak megtekinteni a feladatok státuszát,  mikor lett kiosztva , ki kapta meg a feladatot stb.
\item Alkalmazottak adatainak módosítása, esetleges alkalmazottak törlése, hozzáadása.
\item Feladat elindítása, itt egy felugró ablak lesz, amelyben a szükséges adatokat kell kitölteni a vezetőnek. (Validálással).
\item A kiosztott feladatot az alkalmazott belépve megtekinthet, majd ha elvégezte a feladatot, akkor továbbíthatja a következő felhasználónak, visszaküldheti a vezetőnek. A feladat utolsó lépésben mindig a vezetőhöz kerül vissza az elvégzett folyamat.
\item A vezető végig tudja követni a feladat lefolyását.
\item Bejelentkező felület elkészítésé validálással, különböző jogosultságok megkülönböztetése.
\end{enumerate}


\section{Tervezés}
Entity Framework rövid bemutatása : \\

Létre kell hozni egy ConnectionStrings-et , amelyben a Servert nevét, és az Adatbázis nevét kell megadni, $+$ egy Truested Connection értéket. \\


Az adatbázisban lévő kapcsolatok az alábbi methodus felüldefiniálásával lettek megadva.
Létrehoztuk az adatbázisban lévő táblákat osztályonként, majd egy adott osztálybeli DbSet listát hozunk létre. \\
public DbSet<Employee> Employee { get; set; }  \\
public DbSet<Department> Department { get; set; } \\
public DbSet<Duty> Task { get; set; } \\
public DbSet<Leader> Leader { get; set; } \\
\begin{center}
  protected override void OnModelCreating(ModelBuilder modelBuilder) \\
        {
            //reláció 1:1 1:n n:m \\
            base.OnModelCreating(modelBuilder); \\
            modelBuilder.Entity<Employee>() \\
            .HasOne(p => p.Deprartment) \\
            .WithMany(b => b.Employee) \\
            .HasForeignKey(ug => ug.DepartmentId) \\
            .OnDelete(DeleteBehavior.NoAction); \\
            modelBuilder.Entity<Duty>() \\
            .HasKey(bc => new { bc.EmployeeId, bc.LeaderId }); \\
            modelBuilder.Entity<Duty>() \\
                .HasOne(bc => bc.Employee)\\
                .WithMany(b => b.Tasks)\\
                .HasForeignKey(bc => bc.EmployeeId); \\
            modelBuilder.Entity<Duty>() \\
                .HasOne(bc => bc.Leader) \\
                .WithMany(c => c.Tasks) \\
                .HasForeignKey(bc => bc.LeaderId); \\
            modelBuilder.Entity<Department>() \\
             .HasOne(a => a.Leader).WithOne(b => b.Department) \\
             .HasForeignKey<Leader>(e => e.DepartmentId); \\
        }
\end{center}

Az osztály amelyben ezt a methódus megtalálható, egy DbContext osztályból származik le, amely implementálja az Entity Framework sajátosságait.

Fontos az 1:N kapcsolat kialakításánál, hogy az osztály adattagjaként felvegyük egy osztálytípusú listát, amelyből a több származik az egy felé.

\vskip 0.3 true cm

Az adatbázishoz tartozó rekordokat osztályként hozzuk létre.
Az Entity Framework sajátossága, hogy listaként kezeljük az adatbázist, így egy "Select * from DbName" parancs helyett elég meghívni a listának a .toList() methódusát.
Hasonló módon, ha egy rekordot szeretnél az adatbázisba felvinni, akkor a a lista.add() methodussal lehet megtenni.
További a .remove , .hasFirstDefault stb.. \\

Egy példa, a controllerek között egy Post methodust megtekinve : \\

[HttpPost] \\
        public async Task<ActionResult<Department>> PostDepartment(Department department) \\
        { \\
            _context.Department.Add(department); \\
            await _context.SaveChangesAsync(); \\
            return CreatedAtAction("GetDepartment", new { id = department.DepartmentId }, department); \\
        }  \\

Látható, hogy a Department rekordot feltölti a kapott Department osztálytípusú department nevű objektummal a   _context.Department.Add(department); résznél.

A projekt felépítése több komponensből tevődik össze.
Model rész, ahol az adatbázisnak megfelelő osztályok implementációja történik.
\\ A Controller rész, amelyben a szerver felé irányuló kérések implementációja kerül.
\\Pár alapvető kérés, mint a Post , amelyel egy új rekordot viszünk fel,  PUT amelyel egy meglévő adatot módosítunk , Delete amelyel törlünk , Get amely lekérdezi, vagy listázza az adatokat. Fontos a kivételkezelés ezekben a metódusokban, például, ha egy nemlétező azonosítójú mezőt szeretnénk módosítani, akkor egy kivételt dobjon, és ne a rendszer fagyjon le, esetleg álljon le.
Data részben vannak az adatbázisban lévő kapcsolatok kialakítva, az itt definiált osztály, a DbSet osztályból származik.
Migration, amely a projekt sikeres Build-elése , a nuget consolbe beírt  'Add-Migration Initial' + 'Update-Database' parancs után jön létre, így kialakulnak a kapcsolatok, létrejönnek a táblák. (A connectionStringben megadott Serveren, a megadott adatbázis névvel)

A jelszavak, és egyéb bizalmasan tárolt adatoknál a .net Framework Authentication Hash Algoritmust használt a titkosításhoz.      \\


Üzleti folyamat menedzselése: \\
Vállalati folyamatok automatizálása: Arra a célra szolgál, hogy egy adott szerveretben történő
tevékenységek gördülékenyebben és sokkal hatékonyabban menjenek. \\
Üzleti folyamatnak tekintjük az alábbiakat : \\ egy vagy több tevékenység, amely értéket növel
úgy, hogy egy bemenetkészletet átalakít a kimenetek készletévé.
„Tenner és DeToro” \\
Ez alapján üzleti folyamat lehet akár egy kevés lépésből álló, nem túl bonyolul folyamat, mint
például egy kisebb alkatrész legyártása, vagy az is, hogy valaki éppen egy elemzéshez
összesíti két táblázat adatait, így a vezetőség válláról levéve a terhet, ezáltal marad ideje
potenciálisan nagyobb értékű feladatokra. Egy üzleti folyamat akár előző példáknál lehet
sokkal komplexebb lépéssorozat, például egy nagyobb szervezetnél történő eszköz,
szolgáltatás előállítása is.  \\

A BPM platform folyamatosan próbálja meg tökéletesíteni a folyamatokat. Épp ezért
„folyamatoptimalizációs folyamatként” is lehet értelmezni. \\

 Előnye, hogy segít abban, hogy könnyebben tudjanak változni, mint egy minőségét tekintve
hagyományos, hierarchikus kezelési módszer. Továbbá, a költségcsökkenés mellett,
környezetvédelmi okokból is fontos a feleslegesen használt erőforrások minimalizálása, mint
az irodákban a papírmentesség \\

Az üzleti folyamatok optimalizálásának 5 alapvető építő köve van. \\
1. fázisban a Tervezés, amelyben magába foglalja a meglévő folyamatok beazonosítását
illetve a későbbiekben lehetségesen létrehozandó folyamatok tervezését. \\ Esetünkben 2 ilyen
rendszerbe integrált folyamatról lesz szó. Egy karbantartási, és egy Személygépjármű
igénylési folyamatról.\\

A megfelelően megtervezett rendszertervezés csökkenti a hibák számát a folyamat használata
során.\\

(Esetlegesen rossz jóváhagyóhoz kerül a folyamat, vagy egy végtelen ciklusba, mivel egy
elágazás vagy ciklusnál nem megfelelően, strukturáltan lett megtervezve. ) \\

 Tehát ennek a lépésnek az célja, hogy biztosítsa, hogy egy korrekt és hatékony elméleti
tervezés van elkészítve.\\


2. fázisban a Modellezés kap szerepet, amelynek a lényege, hogy a meglévő modellezést
alapul veszi az elméleti tervezést majd ezt követően beleveszi a változók kombinációját. Itt a
jövőbe történő elemzések is szóba jöhetnek, mint például milyen lehet az, hogyha az
erőforrások bizonyos százaléka ugyanazt a feladatot hajtja végre stb. \\


3. fázisban a végrehajtás\\
Mivel a gyakorlatban ritkán hajtják végre egy folyamat során az összes utasítást, ezért olyan
alkalmazások fejlesztése, amely a szükséges lépéseket elvégzi.
Megközelítés lehet az, hogy a szoftverek és emberek együttműködnek, viszont ez a
dokumentációt bonyolultabbá teszi. \\


4. fázisban a Monitorozás vagy ellenőrzés, ahol a különböző folyamatok nyomon követését ,
és állapotát lehet tudjuk megtekinteni. \\

Az 5. fázis \\ Az Optimalizálás szerepe hogy alkalmazza a potenciális vagy aktuális
torlódásokat illetve információk nyerjen ki a különböző fáziskból, mint például a modellezési
vagy a monitorozási fázisból folyamat tervezésében ezeket az információkat felhasználja. \\

A folyamatos teljesítmény ellenőrzés során észlelt realizált és elvárt eredmények közötti
különbségek csökkentésére helyezzük a hangsúlyt az optimalizálás lépésének során.\\

A BPM projekt elkészítéséhez álltalában valamilyen külső, erre szakosodott tanácsadót, vagy
egy elemzőt szoktak alkalmazni, akik felmérik a működését, majd javaslatokat tesznek a
változtatásokra. Erre azért van szükség, mivel ő nem része a cégnek, így objektíven tudja
elemezni a rábízott műveleteket. \\

A felmérést követően a folyamatokból rengeteg (végtelen) fajtát , költségűt és méretűt lehetne
felrajzolni, ám ez nagyban függ a megbízó cég stratégiájától, vágyaitól, költségvetésétől,
illetve azoktól a szoftverektől , amelyeket használ. \\

A különböző vállalati folyamatoknak 2 féle osztályozása van. \\
Első a Portel Model, amelyben az iparági versenyt öt fontos tényező határozza meg , mint az
új belépők, a helyettesítő termékek fenyegetése, a vevők alkupozíciója, a szállítók alku ereje,
valamint a meglévő versenytársakkal folytatott versengés. A második megközelítés az APQC
folyamatkategorizálási séma. \\

Fontos megemlíteni a folyamatban használt grafikus leírását, amiért a JBPM felelős, amely
Java nyelvben íródott. Egy folyamat több tevékenységből áll, amelyeket átmenetek kapcsolnak
össze. A folyamat grafikus leírása a fejlesztő és a megrendelő közötti kommunikációt segíti. \\

Egyéb, hasonló rendszerként szokták említeni a CRM rendszert (Customer Relationship
Management) , amely egy cég saját partnerei felé irányuló folyamatainak leírására
vonatkozik. \\
CRM szoftver célja, hogy ezeket a folyamatokat támogassa, illetve a jelenlegi és potenciális
ügyfelekkel kapcsolatos információkat tárolja. \\


CRM rendszert használunk az ügyfelekkel fenntartott kapcsolatok kezelésére.
Irányítson egy értékesítési csatornát, készítsen értékesítési célokat, hasonlítsa össze
az értékesítési csapatokat, kövesse nyomon a támogatási kérdéseket, kezelje az
SLA-kat stb. A CRM általában bármit tartalmaz, amely kapcsolatban áll az ügyféllel,
ezért a neve: Ügyfélkapcsolat-kezelő rendszer. \\
A BPM rendszer mind a folyamatokra, mind a szoftverekre vonatkozik, a CRM-hez
képest egy sokkal átfogóbb alkalmazást foglal magában, amelyben az ügyfelek
számára meghatározott alkalmazásra utal. \\ Úgy hasonlíthatnánk össze őket, hogy a
BPM egy ház, amíg a CRM egy szoba. A BPM szoftver tartalmazhat CRM funkciót,
fordítva nem. \\

Az üzleti folyamatok kezelésére BPM rendszert (Business Process Management
system) használnak. Kétféle típus létezik: \\
BPM rendszer: az üzleti folyamatok tervezésére, szimulálására és optimalizálására
szolgáló rendszer. Ezek elsősorban az információ elemzők, építészek stb. Eszközei.
Alig kapcsolódnak közvetlenül a vállalkozás működési szintjéhez. \\
BPMS: olyan rendszer, amely lehetővé teszi az üzleti folyamatok tervezését, de ezen
folyamatok végrehajtását is (más néven munkafolyamat). Ezeket a rendszereket az
egész társaságban lehet használni. Az építészet szintjétől az operatív szintig. \\


Maga az kezelő felület megjelenése teljesen dinamikus. A statikus tartalom itt azokat a
tartalmakat jelenti, amelyeket az oldalon nem változnak vagy csak ritka esetben változnak,
ilyen például folyamatok megnevezése, és a hozzájuk tartozó view pagen lévő mezők, illetve
a különböző kilistázási és módosító műveletek, vagy esetleg a céget bemutató szöveg, cég
logó. \\
Ezek az adatok közvetlen a React html (jsx) fájlaiban szerepelnek. A dinamikus tartalmak
pedig az adatbázisból töltődnek az oldal felületére, ilyenek például a felhasználók által felvitt
értékek egy folyamat során , akár az adatok betöltődésénél egy kiolvasási rész, akár egy
adatbázisba történő beszúrás, az első lépésben. A különböző dolgozó menedzselése, amely
során az adataikat lehet változtatni, esetleg törölni az adatbázisból, vagy egy új dolgozót
hozzáadni ahhoz. \\
Ami pedig a dinamikus megjelenést illeti, amelyben a react js elterjedt bootstrapje nyújt
segítséget, ebben az esetben azt jelenti, hogy a felhasználó bármilyen készülékről is
használja a vállalati alkalamzást (akár egy kisebb irodai laptop, akár egy nagy monitorral
rendelkező számítógép, Tablet ) , a tartalom átláthatóan és érthetően, a készülék méretéhez
igazítva jelenik meg. Nem lát kevesebb tartalmat és nem korlátozottabb az alkalmazás
használatában, egyszerűen csak egy más elrendezésű felületet kap, ami az adott készülékhez
igazodik. \\

A react js bootstrapjében rengeteg előre definiált stílusú objektumot tudtunk felhasználni,
amelyektől a weboldal sokkal felhasználó barátabb lesz a dolgozók számára. \\
Maga a felület a minimalista megjelenésre törekszik a könnyebb és átláthatóbb tartalom
közvetítése és használhatósága végett. \\
A vállalat dolgozóinak lehetősége van bejelentkezni a programba. Ezt email címük és jelszó
segítségével tudják megtenni. Ezután fogja tudni ténylegesen használni a programot.
Amennyiben hibás adatokkal próbál valaki belépni, egy hibaüzenet ugrik fel: "Érvénytelen
adatok. Adjon meg egy meglévő dolgozó adatait, vagy vegye fel a kapcsolatot az
ügyfélszolgálattal." \\

Bejelentkezés követően a felhasználó megtekintheti a kapott feladatokat egy külön erre
szolgáló menüpontban. Továbbá amennyiben jogosult rá, lehetősége van a rendszerbe
implementált folyamatok közül elindítani egyet. Két alapvető folyamat lesz definiálva a
rendszerben, egy személy gépjármű igénylő és egy karbantartási folyamat. \\
Több felhasználót különböztet meg a rendszer. \\
Erős felhasználó : Egy cégnél dolgozó felhasználó, akinek a szándéka a program tényleges
használata, a feladatok megtekintése, esetleg folyamatok elindítása. \\
Vezető : ő a programot egész átfogóan használja, annak minden egyes funkciójával együtt.
Lehetősége van a cégben dolgozó személyek adatainak módosítására, törlésére, különböző
lekérdezéskre. \\

A rendszer további előnye a felhasználóbarát szemléletnek köszönhetően különösebb
betanulási időt nem igényel, legfeljebb 5 perc alatt mindenki képes lesz elérni a kívánt
tartalmat, folyamatot elindítani, a feladatokat megtekinteni. \\
A folyamat elindításához szükség van az előre leimplementált draft űrlap minden kötelező
mezőjének a kitöltése, majd a submit gombra kattintva elküldheti a felhasználó a következő
illetékes személynek a folyamatot. \\
Ezután a program az adatokat lementi az adatbázisba, hogy a következő jóváhagyónál ezt
kiolvassa, és megjelenítse neki a felvitt adatokat, ha mentési hiba történne, akkor azt egy
hibajelző üzenettel a felhasználó tudomására adná a program. Hibaüzenettel alapvetően nem
találkozni, a dátum formátumra egy külön, React Bootstrapbe beépített rész lesz alkalmazva, a
helytelen formátum megadás elkerülésének érdekében. Továbbá az Érvénytelen számot adott
meg és hasonlók. \\

Technológiák részletesebb bemutatása: \\
Frontend részről használt technológia bemutatása : \\
-React : A react js egy Javascript könyvtár, amelyet a Facebook, Community és egyéb hasonló
vállalatok tartanak fent. \\
Az egyik különlegessége, hogy egy bizonyos „jsx” típussal tér vissza, amely egy html kód. \\
Ahhoz, hogy létrehozzunk egy React projektet az alábbi parancsok szükségesek: \\
Első fontos parancs: npm create-react-app , vagy npm install –g create-react-app . \\
Egy react csomagot kell telepíteni, mivel ez is egy node package, ezzel a paranccsal
telepítjük. Ezt a facebook fejlesztése, hogy mindenféle bonyolult konfiguráció nélkül tudjuk
elkezdeni a fejlesztést, mivel ezt már alapból megcsinálja. \\
A tartalmát később részletezzük

npx-create-react-app application-name , ezzel létrehozzuk magát, a projektünk mappáját, és a
bennelévő node modulokat. \\
A mappába belépve, az „npm start” parancsot kiadva tudjuk szerveren elindítani a projektet. \\
A node_modules csomagokat a package.json mappában lévő 3 fő függőség (react , react-dom
, react-scripts) alapján telepíti fel. \\

A package.json-ben vannak korábban említett, már előre megírt scriptek (start,build, test,
eject) \\
Start (npm start) – Ezzel a parancsal lehet a szerveren elindítani a projektet. \\
Build (npm run build)- a végleges változatot fordítja le, ezzel egy olyan állapothoz lehet jutni,
amit fel lehet tenni a szerverre. \\
Test (npm test)-A tesztet fogja lefuttatni \\
eject (npm run eject)– A konfigurációs fájlokat át lehet írni, de ezt már nem lehet visszavonni
a parancs után, ha nincs verzió kezelve a projektet. Alapvetően nem ajánlott. \\

Mint a legtöbb Javascript keretrendszerben, a src mappában vannak js kiterjesztésű , fő fileok. \\
ES6 szintaktikát használ a React, hiszen a különböző komponenseket importáljuk be, majd ez
automatikusan átfordul egy korábbi scriptre, hogy a böngészőkön könnyebben futhassanak. \\
Több komponenst különböztetünk meg. \\
Minden Komponensnek kötelező jelleggel van egy Render() függvénye, amelynek a
visszatérési értéke egy „html” , amely úgynevezett JSX. \\


Ennek az előnye az, hogy átláthatóbbá és könnyebbé teszi a kódolást. \\
react dom kezelés: \\
Szintaktikája: \\
Az egyik legáltalánosabb metódusa a .render , amely 2 bemeneti paramétert vár. \\
Az első bemeneti paraméter, az maga a JSX kód, a második pedig az, hogy hova generálja az
adott kódot. \\
Minta :\\
ReactDom.render(JSX , (document.getElementById(’Id’)) ) \\
Vannak bizonyos komponensek, ahol nem szükséges a Render methódus, ez az úgynevezett
Stateless Komponens, amely Önmagában egy függvény. \\
const Vehicle =()=>{ \\
return ( \\
<div> Text </div> \\
) \\
}\\
export default Vehicle; \\
Ki kell adni (Exportálni), hogy ezt a komponenst további helyekre is belehessen importálni, a
következő paranccsal: \\


import Vehicle from ’./path’ \\
Az importálást követően, ha hivatkozni szeretnénk a komponensen belül a Vehicle
függvényre, akkor azt a Render metóduson belül, html Tag-ként hivatkozhatunk , <Vehicle/>
szintaktikával tehetjük meg. \\
Amennyiben a stateless komponensnek tulajdonságokat szeretnénk átadni, akkor azt a
paraméter listában kell jelölnünk, ekkor az alábbira módosul a függvényünk. \\


const Vehicle =(props)=>{ \\
return ( \\
<div> {props.type}</div> \\
) \\
} \\
export default Vehicle; \\
A függvény kifogja írni a beérkező props-nak a type-ját. \\
A render methódusban pedig a tagre az alábbi módon hivatkozhatunk : \\
<Vehicle type=”opel” /> \\


Amennyiben egy sima komponenst hozunk létre, több különböző beépített metódust tudunk
használni. (Ezek az ős komponensből származnak ) \\
Ilyenek például az alábbiak : \\
ComponentWillMounth- A metódusban definiált tevékenységek lefutnak a Render függvény
előtt. \\
ComponentDidMounth- A metódusban definiált tevékenységek, a Render függvény után
futnak majd le. \\
További előnyei, hogy a komponensen belül létre tudunk hozni construktort illetve state-et és
egyéb más dolgokat. \\

Az implementáció során a Microsoft Sql Szerver adatbázis-kezelő szerverre jutott a döntés,
mivel az Entity Frameworkkel törénő adatbázis kezelés egy magas szintű absztakciót nyúlt,
programozási technika adatok konvertálására Visual Studioban, nem beszélve a kiváló
támogatottságáról, illetve a gyorsasága és megbízhatóságáról. Az ingyenes verzióban pedig
minden szükséges funkció elérhető a programunk működtetéséhez. \\
Amikor elkezdünk objektum orientált nyelvben programozni, akkor az adatkezelési feladatot
álltalában az objektumok módosításával végezzük.
Ez az úgynevezett Object-relational mapping (ORM).\\


Összehasonlítva a hagyományos módszerrel, az ORM gyakran lecsökkenti a megírandó kód
mennyiségét, objektumorientált nyelv és relációs adatbázis közötti adatcsere esetén.
Az ORM hátrányos az olyan területeken, rendszerekben ahol az adatbázist jelentősen
optimalizálják speciális technikák alapján.  \\

Ahhoz, hogy az Entity Frameworköt használatba tudjunk fenni, különböző szükséges toolokat kell telepíteni a programba, amelyeket a visual studióban megtalálunk, mint például: \\

Microsoft.EntityFrameworkCore \\
Microsoft.EntityFrameworkCore.Design \\
Microsoft.EntityFrameworkCore.SqlServer \\
Microsoft.EntityFrameworkCore.Design \\
Microsoft.EntityFrameworkCore.Tools \\
Az Entity Framework előnye, hogy az adatbázisban lévő adatokat lista szerkezetként tudjuk
kezelni, így a megszokott adatbázis parancsokat felcserélhetjük, egy egyszerűbb
szintaktikával rendelkező kódolásra. \\

Összehasonlítva : \\
Egy listázást az alábbi módon tudjuk megtenni, mind sql-ben , mind Entity Frameworköt
használva. \\
Select * from TableName helyett használhatjuk a listanév.toList() szintaktikával tehetjük
meg. \\
Az adatbázisba történő beszúrás, egy Insert Into TableName values parancs helyett
könnyedén alkalmazhatunk egy .Add() metódust, ahol a paraméter listába az adatbázisnak
megfelelően egy osztály példánya kerül. \\
Egy feltételekhez kötött listázás szintaktikája is tovább egyszerüsödik, hiszen a Select *from
tablename where feltétel helyett használhatjauk a listanév.where(feltétel) parancsot. \\

További sajátosságai, jelentősen megkönnyítik a szerver oldali implementációt, a kliens
oldallal történő kommunikáció használatára pedig json (Javascript Object Notation)-t
használunk, amely tulajdonképpen rendezett érték lista amely , egy név és érték párok
gyüjteménye dupla idézőjel párok között megadva. \\

Általános szintaktikája : \\
{ "name":"value", \\
"name2":"value2" \\
} \\
Kezdetben a szerver oldali tesztelés, adatok felvitele, listázása és egyéb alapvető funkciók a
Postman nevű alkalmazásban történik. \\
Mivel a Json sokkal könyebben értelmezhető, mint az xml, ezért esett erre a választás. \\


További lényeges implementáció szükséges a szerver oldalon ahhoz, a frontend értelmezni
tudja a kapott értékeket. \\
Az alapvető Requesteket , a Microsoft által készített .NET keretrendszerben kerültek
implementálásra. \\
A keretrendszer előnyei közé tartozik szintén a megfelelő támogatottság, hiszen egy
Microsoft és a Xamarin áll mögötte, Mivel .NET Framework alapját a CLI, vagyis a Common
language Interface képezi, ezért a platformfüggetlenség, illetve a gyors alkalmazás
fejlesztés (RAD, Rapid application development). \\

A CLI rendszerek leírják nyelvfüggetlen fejlesztői környezetet, a futtatókörnyezetet,
típusrendszert. \\
Négy fő része van : \\
1. A CLS, amely azokat a szabályokat írja le, amelyeket a CLI-kompatibilis nyelveknek
be kell tartaniuk \\
2. A CTS, amely a CLI azon része, ahol a típusokat, és azoknak a memóriaban történő
reprezentációját illetve egymással való kapcsolatait írja le. \\
3. CLR, amely a CLI nyelven megírt programok betöltéséért és végrehajtásáért felel. \\


A gyors alkalmazás fejlesztéshez használt módszertan 3 fő elemből tevődik össze: \\
Ciklikus fejlesztés, működő prototípusok létrehozása, és a szoftverfejlesztést támogató
számítógépes programok.\\

Előnye: Az alkalmazások elkészítése egyszerűbbé válik , amelyhez hozzátartozik egy
felhasználóbarát kezelőfelület, illetve egy uniformizált platform megjelenése. \\

\section{Road Transportation Demand}
Az első üzleti folyamat, amely a személygépkocsi igénylése, tulajdonképpen egy
elég egyszerű (2 lépéses folyamat), itt talán felugró mezők okozzák a
legnagyobb kihívást.\\
A folyamat első, draft lépése így nézne ki :\\
\newpage
\section{KÉP}
\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{images/road1.png}
\caption{Minta kép}
\label{fig:minta}
\end{figure}

Az igénylés típusát kiválasztva, olyan mezők adódnak hozzá a folyamathoz, amelyek a jelenlegi
képernyő fotón nem látszódnak. \\
A következő az igénylő szervezeti egység lenne, amely egy felugró kereső ablak , ahol a felhasználó
kiválasztja azt, hogy melyik szervezethez tartozik. \\
Ez egy külön adatbázis tábla lenne, amelyben a cégnél nyilvántartott szervezetek lesznek eltárolva,
majd a felugró ablakban, ezekből lehet választani. \\
Több mező is a felhasználó álltál kiválasztott Checkbox szerint jelenik majd meg, és tűnik el.
Vegyük példaként azt, ha a felhasználó kiválasztja az igénylés típusánál a „Járművezetővel ellátott
személygépkocsit” : \\
\newpage
\section{KÉP}
\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{images/road2.png}
\caption{Minta kép}
\label{fig:minta}
\end{figure}

Ekkor megjelenik egy új kiválasztós mező, amelyben az Oda út és visszaútról kérdez, illetve négy
további mező, amely a gépjármű elvitelének és a gépjármű leadásának az idejéről, illetve a gépjármű
elviteli ideje + leadási ideje. \\
Ha csak „egy út” van kiválasztva, akkor a gépjármű leadásának dátuma, és ideje mező eltűnik,
ellenkező esetben megmarad. \\
Lehetőségünk van több utast is hozzáadni, amelyben a hozzáadás gomra kattintva felugrik egy rész,
ahol az adatokat kérjük le. \\
Ez szintén egy új táblázat lesz (Road Transportation Demand DTL), amelyből 1 folyamathoz, akár több
is tartozhat. \\

\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{images/road3.png}
\caption{Minta kép}
\label{fig:minta}
\end{figure}

Itt az Utas neve, egy szintén felugró ablak, amelyből kiválaszthat a cég alkalmazottak közül egyet. \\
Az utasok a User táblából lesznek Listázva, amelyben nyilván van tartva a cég összes alkalmazottja,
annyi eltéréssel, hogy az utasnak nem lesz költség helyi kódja. \\
Tetszőleges számú utast adhatunk hozzá, illetve tudjuk törölni is őket. \\
Ha kitöltötte a felhasználó a mezőket, akkor a Submit gombra kattintva a következő, approve lépésbe
ér a folyamat, ahol a meglévő adatok kiolvasása történik. Itt láthatja a következő illetékes azt, hogy
milyen adatokkal szeretnének járművel bérelni. \\
Mivel ez egy egyszerű, 2 lépéses folyamat, egy Draft és egy Approve lépésből állt, a folyamat ezt
követően véget is ért. \\

\section{Road Transportation Maintance}
A második üzleti folyamat, amely egy karbantartási folyamat. \\
Ez egy komplexebb folyamat, itt több lépés van, mint az előzőben, illetve itt is
megtalálhatóak a Checkbox szerinti kiválasztással felugró mezők. \\
Az első lépést, az-az a draft-ot itt láthatjuk : \\
\section{KÉP}

\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{images/road4.png}
\caption{Minta kép}
\label{fig:minta}
\end{figure}
\newpage
Itt az első kiválasztott érték esetén, ha az nem jármű, akkor az alábbi mezőt kapjuk meg:\\
\section{ KÉP}
\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{images/road5.png}
\caption{Minta kép}
\label{fig:minta}
\end{figure}

Amennyiben a folyamatban a Jármű kerül kiválasztásra, akkor egy rendszámot kell beírni, amely
szintén egy külön tábla lesz, hiszen több rendszámot kell nyilvántartani, és a gépjárművekhez tartozó
további adatokat is, mivel a keresés gomra kattintva, automatikusan kitöltődnek a readonly mezők
értékei, mint a Márka, típus, Üzemóra , Futott Kilométer stb. \\
Ezután a probléma leírása rész következik, ahol egy tetszőleges leírást adhat az igénylő felhasználó.
Ezt követően a második (Approve) lépésben az alábbi rész jelenik meg: \\

\section{KÉP}
\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{images/road6.png}
\caption{Minta kép}
\label{fig:minta}
\end{figure}

Itt a kiolvasott adatok mellett megjelenik egy újabb kitöltő mező, amelyben a Supervisor Descripont
kell megadni. \\
A következő 3. lépésben pedig azt kell megadni, hogy a probléma típusát, amely lehet Személyes,
Belső, vagy külső probléma. \\
Amennyiben a probléma típusa Belső, vagy Külső, akkor egy újabb mező ugrik fel, amelyben szintén a
meglévő alkalmazottak közül kell kiválasztani azt, hogy a folyamat kihez megy tovább, ki lesz érte a
felelős. \\
A megjelenő oldalt itt láthatjuk :  \\
\newpage
\section{KÉP}
\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{images/road7.png}
\caption{Minta kép}
\label{fig:minta}
\end{figure}


\section{KÉP}

Tesztelésként kiválasztjuk az Internált, majd továbbítjuk, akkor az általunk megadott Ownerhez fog a
folyamat tovább menni.  \\

\section{KÉP}
\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{images/road8.png}
\caption{Minta kép}
\label{fig:minta}
\end{figure}

Ezután, az illetékes az alábbi formot fogja látni : \\
\newpage
\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{images/road9.png}
\caption{Minta kép}
\label{fig:minta}
\end{figure}

Itt az alábbi adatokat megadva, visszatér a folyamat az előző lépésben lévő emberhez, aki megkapja
ezeket az adatokat, és jóváhagyja. \\
Ezáltal vége a folyamatnak. Amennyiben a „Personal” részt választotta volna ki, akkor ott lett volna
vége a folyamatnak. \\

\section{Bevezetés a saját program vázának elkészítésébe}
Ebben a fejezetben bemutatásra kerül a folyamatmenedzsment rendszer
felhasználói felülete illetve az adatbázis modellje. A felhasználói felületet
képernyőfotókkal készítve, egy kisebb változatú, de hasonló célú projekttel
mutatom be, illetve mindegyikhez adunk egy-egy rövid leírást az adott felhasználói
felület funkcióiról. \\
A programunkhoz használt adatbázis leírása és bemutatása után pedig részletesen
bemutatjuk a programunk adatmodelljét, ER és relációs modell segítségével. \\

\section{2. Felhasználói felület}

Ebben a fejezetben bemutatásra kerülnek a felhasználói felület elemei, melyeken
keresztül a felhasználó a programot használni fogja. A felhasználói felület
kialakítása során törekedtünk az egyszerűségre és az átláthatóságra, hogy a
felhasználó számára a lehető legegyszerűbb legyen a program használata. Ez
csökkenti a felhasználó által használt programidőt, ezáltal programunk kevésbé lesz
hajlamos a lassúságra, illetve az esetleges összeomlásra. Ezért az egyes funkciókat
úgy próbáltuk megoldani, hogy azok a felhasználó ezen a területen szerzett előzetes
tapasztalatainak megfeleljenek. A React.js alapvető bootstrapjét használjuk a
projekt implementálásánál, amelyet a következő parancs telepítése után vehetünk
igénybe.
\begin{center}
  npm install react-bootstrap bootstrap \\
majd beimportáljuk a projektbe. \\
<link \\
 rel="stylesheet" \\

href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min. \\
css" \\
 integrity="sha384- \\
9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" \\
 crossorigin="anonymous" \\
/> \\
\end{center}
Ezáltal képesek vagyunk responsive oldalt létrehozni, illetve felhasználni a
React.js material componenseit, amelyeket az alábbi oldalon találhatunk. \\
https://material-ui.com/components/snackbars/ \\

A részlegek felülete: \\

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/ListDepartment.png}

\end{figure}

\newpage
Vezetőként belépve, lehetőségünk van a részlegek megtekintésére, törlésére,
módosítására. \\
Edit gomra kattintva, egy felugró ablak jelenik meg, amely kiolvassa, az aktuális
mezőhöz tartozó adatokat, ezek alapján lehet módosítani. \\
A felugró ablak hasonlóképpen néz ki: (A mezőhöz tartozó DepartmentID
Disabled, hiszen azt nem lehet módosítani) \\

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/EditDepartment.png}

\label{fig:minta}
\end{figure}

A törlés gomb megnyomásával egy Alert rész ugrik fel, rákérdez arra, hogy
„Biztosan szeretnéd törölni”? \\
Ugyanezen a formon lehetőségünk van egy részleg hozzáadására, az Id
automatikusan incrementálódik, tehát a felhasználónak csak magát a részleg
nevét kell megadnia. \\
\newpage
Az Alkamazottak felülete : \\

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/ListEmployee.png}

\label{fig:minta}
\end{figure}
 
A design és a funkciók hasonlóak az előző fórumom láttottakhoz, a tárolt
adatok különböznek, illetve van még némi különbség. \\
Ha egy új dolgozót szeretnénk felvenni a rendszerbe, akkor a részleg
kiválasztásnál, a meglévő részlegek közül tudunk választani, egy legördülő
listában. (Ezzel korlátozva azt, hogy hibás részleget adjon meg a felhasználó,
vagy nemlétezőt. ) \\
\newpage
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/addemployee.png}

\label{fig:minta}
\end{figure}


Az adatbázisban felvett Dátum típus miatt problémák lehetnek azzal, ha
hibásan kezeljük a forumon leimplementált Dátum mezőt. \\
Ebből kifolyólag, egy Dátum típusú Form Control lett megadva, a helytelen
konvenciók miatt. \\
\newpage
Ez az alábbi képen tekinthető meg : \\
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/EditEmployee.png}

\label{fig:minta}
\end{figure}


Mivel két különböző szerveren fut a Backend és a Frontend, így a
kommunikációt Json formátum segítségével lesz megoldva, amelyben a
Backend oldalon az alábbi rész kerül implementációra. \\
Ahhoz hogy a két server kommunikálni tudjon egymással, és ne írjon hibát, fel
kell oldani egy Cors problémát a .net résznél, hogy ez megvalósuljon. \\
Mivel a frontend a 3000-as porton érhető el így az implementációja az alábbi
formátumban lesz, a nuget csomagok telepítése után :  \\

config.EnableCors(new EnableCorsAttribute("http://localhost:3000", "*", "*")); \\

A json formátummá alakításhoz pedig : \\
config.Formatters.JsonFormatter.SupportedMediaTypes.Add( \\
 new MediaTypeHeaderValue("text/html")); \\
Így ha a fentebbi listát tekintjük meg Backend oldalon , akkor az alábbi Json \\
formátumot fogjuk látni :  \\

\newpage
A department részleg esetén : \\

\begin{figure}[h]
\centering
\includegraphics[scale=0.3]{images/DepartmentJson.png}

\label{fig:minta}
\end{figure}


Az employee részleg esetén : \\
\begin{figure}[h]
\centering
\includegraphics[scale=0.3]{images/EmployeeJson.png}

\label{fig:minta}
\end{figure}



A Cliens oldali részről, ahhoz hogy ezt a Json formátumot használhatóvá tudjuk
tenni, a ComponentDidMount függvényen belül definiálni kell a \\
fetch('https://localhost:44315/api/Department')
illetve a \\
fetch('https://localhost:44315/api/Employee) \\
részeket. \\
Különböző kéréseket adhatunk meg a függvényen belül, (Post, Put, Get, Delete) \\
Amelyek az alábbi szintaktikával kerülnek implementálásra:  \\
\newpage
\begin{figure}[h]
\centering
\includegraphics[scale=0.2]{images/vsCodeJson.png}

\label{fig:minta}
\end{figure}


Amíg a Kliens oldali rész nem került implementálásba, addig az alapvető CRUD
metódusok tesztelése a Postman segítségével történt, ahol kiválaszthatjuk hogy
Post / Delete / Update / Delete methodust szeretnék végrehajtani , az adott
URL-en.

Itt egy adat kerül hozzáadásra, az Alkalmazottak mezőhöz. A post methodusnál
a kivételkezelés kifejezetten fontos, így hibás adat esetén nem kaptunk volna
sikeres visszajelzést.

\begin{figure}[h]
\centering
\includegraphics[scale=0.2]{images/PostmanJson.png}

\label{fig:minta}
\end{figure}

\textsl{ \\Megjegyzés. Témával kapcsolatos, hasznos források : }



\end{document}

