\Chapter{Tervezés}

Entity Framework rövid bemutatása : 

Létre kell hozni egy ConnectionStrings-et , amelyben a Servert nevét, és az Adatbázis nevét kell megadni, + egy Truested_Connection-értéket.


Az adatbázisban lévő kapcsolatok az alábbi methodus felüldefiniálásával lettek megadva.
Létrehoztuk az adatbázisban lévő táblákat osztályonként, majd egy adott osztálybeli DbSet listát hozunk létre. 
public DbSet<Employee> Employee { get; set; }
public DbSet<Department> Department { get; set; }
public DbSet<Duty> Task { get; set; }
public DbSet<Leader> Leader { get; set; }

protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            //reláció 1:1 1:n n:m
            base.OnModelCreating(modelBuilder);
            modelBuilder.Entity<Employee>()
            .HasOne(p => p.Deprartment)
            .WithMany(b => b.Employee)
            .HasForeignKey(ug => ug.DepartmentId)
            .OnDelete(DeleteBehavior.NoAction);
            modelBuilder.Entity<Duty>()
            .HasKey(bc => new { bc.EmployeeId, bc.LeaderId });
            modelBuilder.Entity<Duty>()
                .HasOne(bc => bc.Employee)
                .WithMany(b => b.Tasks)
                .HasForeignKey(bc => bc.EmployeeId);
            modelBuilder.Entity<Duty>()
                .HasOne(bc => bc.Leader)
                .WithMany(c => c.Tasks)
                .HasForeignKey(bc => bc.LeaderId);
            modelBuilder.Entity<Department>()
             .HasOne(a => a.Leader).WithOne(b => b.Department)
             .HasForeignKey<Leader>(e => e.DepartmentId);
        }
Az osztály amelyben ezt a methódus megtalálható, egy DbContext osztályból származik le, amely implementálja az Entity Framework sajátosságait.

Fontos az 1:N kapcsolat kialakításánál, hogy az osztály adattagjaként felvegyük egy osztálytípusú listát, amelyből a több származik az egy felé.

Az adatbázishoz tartozó rekordokat osztályként hozzuk létre.
Az Entity Framework sajátossága, hogy listaként kezeljük az adatbázist, így egy "Select * from DbName" parancs helyett elég meghívni a listának a .toList() methódusát.
Hasonló módon, ha egy rekordot szeretnél az adatbázisba felvinni, akkor a a lista.add() methodussal lehet megtenni.
További a .remove , .hasFirstDefault stb..

Egy példa, a controllerek között egy Post methodust megtekinve : 

[HttpPost]
        public async Task<ActionResult<Department>> PostDepartment(Department department)
        {
            _context.Department.Add(department);
            await _context.SaveChangesAsync();
            return CreatedAtAction("GetDepartment", new { id = department.DepartmentId }, department);
        }

Látható, hogy a Department rekordot feltölti a kapott Department osztálytípusú department nevű objektummal a   _context.Department.Add(department); résznél.

A projekt felépítése több komponensből tevődik össze. 
Model rész, ahol az adatbázisnak megfelelő osztályok implementációja történik.
Controller rész, amelyben a szerver felé irányuló kérések implementációja kerül. 
Pár alapvető kérés, mint a Post , amelyel egy új rekordot viszünk fel,  PUT amelyel egy meglévő adatot módosítunk , Delete amelyel törlünk , Get amely lekérdezi, vagy listázza az adatokat. Fontos a kivételkezelés ezekben a metódusokban, például, ha egy nemlétező azonosítójú mezőt szeretnénk módosítani, akkor egy kivételt dobjon, és ne a rendszer fagyjon le, esetleg álljon le.
Data részben vannak az adatbázisban lévő kapcsolatok kialakítva, az itt definiált osztály, a DbSet osztályból származik.
Migration, amely a projekt sikeres Build-elése , a nuget consolbe beírt  'Add-Migration Initial' + 'Update-Database' parancs után jön létre, így kialakulnak a kapcsolatok, létrejönnek a táblák. (A connectionStringben megadott Serveren, a megadott adatbázis névvel) 

A jelszavak, és egyéb bizalmasan tárolt adatoknál a .net Framework Authentication Hash Algoritmust használt a titkosításhoz.




Itt kezdődik a dolgozat lényegi része, úgy értve, hogy a saját munka bemutatása.
Jellemzően ebben szerepelni szoktak blokkdiagramok, a program struktúrájával foglalkozó leírások.
Ehhez célszerű UML ábrákat (például osztály- és szekvenciadiagramokat) használni.

Amennyiben a dolgozat inkább kutatás jellegű, úgy itt lehet konkretizálni a kutatási módszertant, a kutatás tervezett lépéseit, az indoklást, hogy mit, miért és miért pont úgy érdemes csinálni, ahogyan az a későbbiekben majd részletezésre kerül.

Ebben a fejezetben az implementáció nem kell, hogy túl nagy szerepet kapjon.
Ez még csak a tervezési fázis.
(Nyilván ha olyan a téma, hogy magának az implementációnak a módjával foglalkozik, adott formális nyelvet mutat be, úgy a kódpéldákat már innen sem lehet kihagyni.)

\Section{Táblázatok}

Táblázatokhoz a \texttt{table} környezetet ajánlott használni.
Erre egy minta \aref{tab:minta}. táblázat.
A hivatkozáshoz az egyedi \texttt{label} értéke konvenció szerint \texttt{tab:} prefixszel kezdődik.

\begin{table}[h]
\centering
\caption{Minta táblázat. A táblázat felirata a táblázat felett kell legyen!}
\label{tab:minta}
\begin{tabular}{l|c|c|}
a & b & c \\
\hline
1 & 2 & 3 \\
4 & 5 & 6 \\
\hline
\end{tabular}
\end{table}

\Section{Ábrák}

Ábrákat a \texttt{figure} környezettel lehet használni.
A használatára egy példa \aref{fig:cimer}. ábrán látható.
Az \texttt{includegraphics} parancsba 
Az ábrák felirata az ábra alatt kell legyen.
Az ábrák hivatkozásához használt nevet konvenció szerint \texttt{fig:}-el célszerű kezdeni.

\begin{figure}[h]
\centering
\includegraphics[scale=0.3]{images/me_logo.png}
\caption{A Miskolci Egyetem címere.}
\label{fig:cimer}
\end{figure}

\Section{További környezetek}

A matematikai témájú dolgozatokban szükség lehet tételek és bizonyításaik megadására.
Ehhez szintén vannak készen elérhető környezetek.

\begin{definition}
Ez egy definíció
\end{definition}

\begin{lemma}
Ez egy lemma
\end{lemma}

\begin{theorem}
Ez egy tétel
\end{theorem}

\begin{proof}
Ez egy bizonyítás
\end{proof}

\begin{corollary}
Ez egy tétel
\end{corollary}

\begin{remark}
Ez egy megjegyzés
\end{remark}

\begin{example}
Ez egy példa
\end{example}
