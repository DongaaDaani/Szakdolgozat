\Chapter{Véges Determinisztikus autómaták}

\Section{Folyamatok matematikai leírása}

Véges számú állapotból, és egy tranzíciós diagrammból áll, amelynek szakaszait úgynevezett input szimbólumok jellemzik, amelyek ugyanabból a véges $\Sigma$ ábécéből vannak kiválasztva. 

Két kitüntetett állapot van: A kezdő állapot, jele : $q_{0}$ és a végállapot halmaza, amelynek a jele $F$. (Ezek a \textit{Start} és a \textit{Stop} elemnek tekinthetők egy folyamat modellezése esetén.
A \textit{Start} jelzi a folyamatábrán a \textit{draft} lépést, ahonnan elindul maga az üzleti folyamat. A végső lépés, az utolsó jóváhagyó, \textit{approve} lépés pedig a végállapot, amely megfeltethető az $F$-nek.)

Minden állapotban minden egyes bemeneti szimbólumhoz pontosan egy következő állapot tartozik. Diagram esetében pontosan ezek az állapotok közötti nyilak.

\Section{Formális definíció}

Egy véges determinisztikus autómatát a következőképpen definiálunk.
Legyen $A = (Q, \Sigma, \rho, q_{0}, F)$, ahol $Q$ az állapotok halmaza, $\Sigma$ a véges ábécé, $\Sigma \notin \emptyset$, továbbá $\rho$ a tranzíciós függvény, a  $q_{0}$ a kezdő állapot, $q_{0} \in Q $  $F$ a végállapot.

Könnyen belátható, hogy $F \in Q$ illetve $F \notin \emptyset$.

A matematikai modell pontosan megfeleltethető annak, hogy egy folyamat esetén melyik lépésben milyen input adatokat ad meg a felhasználó, mert a következő lépés ezen adatok alapján változik. Például, egy konkrét esetben, ha a felhasználó 300'000 Ft-ot állít be egy becsült költségnek, akkor oda egy igazgatói jóváhagyás szükséges, ellenkező eseben ez a lépés kihagyható. Az ilyen elágazásokat, és ciklusokat követően jutunk el a (modellben $F$-el jelölt) végállapotba.

\Section{Egyszerű átmeneti rendszerek}

A folyamatok egy másik reprezentálási módját adják az átmeneti rendszerek [].
Legyen $A = (S, T, \alpha, \beta)$, ahol
\begin{itemize}
	\item $S$: az állapotok véges, vagy végtelen halmaza,
	\item $T$: az átmentek véges, vagy végtelen halmaza,
	\item $\alpha, \beta$: $T \rightarrow S$ leképzés $\forall t \in T$-re, amelyben $\alpha(t)$ az átmenet kezdőpontja, $\beta(t)$ pedig a végpontja.
\end{itemize}

A modell ebben az esetben is egy irányított gráf, ahol a csúcsok állapotokat reprezentálnak, az élek pedig átmeneteket.

% TODO: Megnézni, hogy a következő kommentezett rész milyen formában kerül további felhasználásra! (Csak akkor kell bele, hogy ha később lesz valamilyen jelentősége.)
% Az $A=(S,T,\alpha,\beta)$ átmeneti rendszerben $n>0$ hosszú útnak nevezünk egy olyan $t_{1},t_{2},\dots,t_{n}$ sorozatot, ha $\beta(t_{i}) = \alpha(t_{i+1})$ teljesül $\forall i\in \{ 1,\dots ,  n-1 \}$-re. \\
% Utak konkatenációja, vagy összefűzése $c * c' = t_{1}t_{2}\dots t_{n} g_{1}\dots $ \\

Jó példa egy egyszerű átmeneti rendszer egy italautómata, amelybe egy rögzített összeget dobva két gombot nyomhat meg a felhasználó.

% TODO: Nem teljesen látszik az FSA-val való kapcsolat.

\Section{A Struktúrált programgráf és a nem determinisztikus autómata}

% TODO: Ez a szakasz nem biztos, hogy kell bele, csak ha ugyanezen jelölések szerepelnek majd később is, illetve, hogy ha a program valódiságát validálni lehet.

A struktúrált programozás olyan programozási elvek összessége, amelyek segítenek
megteremteni, hogy a program szövegszerkezete tükrözze a program végrehajtása
során követett vezérlési folyamatot.


A struktúrált programozás $3$ alapvető elemekből épül fel : Szekvencia , Ciklus , Elágazás . \\

Használt jelölés a szekvenciára : S(tevékenység1, tevékenység2 , $\dots$  , tevékenységn)\\
Ciklus formátuma : C(prédukátum, ciklusmag)\\
Az elágazásra : E(prédukátum,p,q)\\
Fontos jellemzőjük, hogy, minden építőelemnek csak egy belépési és egy kilépési pontja van.
A belépési pont a struktúa elején, a kilépés a végén van.
\\
\begin{center}
	Egy programot valódi programnak nevezünk, ha:
\end{center}

1. programgráfja véges számú nem zérus bemenő éllel és kimenő éllel rendelkezik, \\
2. programgráfjának csomópontjai predikátumok, függvények és gyűjtők, \\
3. programgráfjának minden csomópontján keresztül vezet legalább egy útvonal, \\
amely egy bemenő éllel és egy kimenő éllel rendelkezik ( a programgráf kezdő élétől \\
a kilépési élig vezet).

\Section{Üzleti folyamatokhoz tartozó folyamatábrák}

\begin{figure}[h!]
\centering
\includegraphics[width=6.8truecm, height=6.8truecm]{images/Demand_Process.png}
\caption{Road Transportation Demand}
\label{fig:Demand_Process}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=6.8truecm, height=6.8truecm]{images/Maintance_Process.png}
\caption{Road Transportation Maintance}
\label{fig:Maintance_Process.png}
\end{figure}

\Section{Folyamat megtervezése}

A folyamat tervezésénél fontos szerepe van a strukturáltságnak, ellenkező esetben nagy problémák is adódhatnak, mint egy  végtelen ciklus, esetleg több input bemenet.
\begin{itemize}
	\item Az első azért okozna problémát, mert a folyamat sosem érne véget, nem lenne befejezve.
	\item Ha több input bemenet lenne (több különböző draft page), egy folyamaton belül,  akkor az már egy más folyamathoz tartoznak, egy más igényléshez.
\end{itemize}

A nagyobb és komplexebb folyamatokat, kisebb részekre is bonthatjuk, amelyre csak struktúrált programként van lehetőségünk megadni. Ezt az eljárást
a vezérlőgráf lebontásának nevezzük.

% TODO: A következő rész akkor lehet érdekes, hogy ha egy gráf validátort össze sikerül hozzá rakni.

Lépései:  a struktúrált alapszerkezetek valamelyikét egy függvény csomóponttal helyettesítjük, és ezt mindaddig folytatjuk, amíg ez lehetséges. Az egyetlen csomópontból álló gráfot egyetlen
éllel helyettesítjük.

Megjegyzés:
minden nem strukturált program átírható vele ekvivals strukturált program formályában. \\
Áttérésként a Véges Determinisztikus autómatákra, egy $a\in \Sigma$ betűhöz, és $q_{i}$ állapothoz, pontosan egy output (nyíl) tarotzik. \\
% TODO: Ennél a Böhm-Jacopini tételt lehet hivatkozni.

\Section{Nem determinisztikus autómata}

(Nondeterminisztic Finite Automation) NFA esetén, viszon egy adott $q_{i}$ állapothoz és egy $a\in \Sigma$ jelhez több output is tartozhat, vagy egy sem.
\vskip 0.3 true cm
Tehát lehetséges olyan belső állapota, amiből a beolvasott szimbólum hatására több lehetséges állapot egyikébe mehet át.\\
Láthatjuk , hogy a véges állapotú autómaták megfeleltethetőek a modellezett folyamatoknak.
Egy strukturálatlan alapelemekből felépülő folyamat, megfelel egy Non determinisztikus autómatának.
A struktúrált elemekből felépülő modellezés pedig egy véges állapotú, determinisztikus autómatával.

Mint ahogy a Struktúrált programozánál is említettük, hogy bármely nem struktúrált program átírható, vele ekvivalens struktúrált programmá, ez szintén jellemző a véges állapotú, nondetermenisztikus autómatákra.
Ezt a tranzíciós függvény elkészítésével tudjuk megoldani, amelyben minden olyan állapot, ahonnan egy bizonyos beolvasott szóval több helyre tudunk eljutni, egy új állapotként felvesszük, majd rekurzívan tovább vizsgáljuk.

\Section{DFA és NFA ekvivalenciája}

Legyen adott egy $N = (Q, \Sigma, \rho, q_{0}, F) $ véges nondeterminisztikus autómata. Nyelve legyen $\alpha(n)$. $n$-ből kiindulva szerkezhetünk egy olyan A véges determinisztikus autómatát, amely ugyanazt az $\alpha(n)$ nyelvet fogadja el.\\
\begin{equation}
	A=(P(q),\Sigma,\rho^{'},[q_{0}],F' )
\end{equation}
Ahol Q a részhalmazok összessége, F' pedig a Q mindazon részhalmazai, amelyek legalább egy F beli állapotot tartalmaznak. (Végállapothoz vezetnek)

\begin{align*}
	&& \rho'  \text{ így értelmezhetünk, minden } a\in\Sigma \\
	&&  \rho'([q_{1},q_{2},\dots,q_{n}],a) = \rho(q_{1},a) \cup \rho(q_{2},a) \cup \dots \cup \rho(q_{k},a)
\end{align*}

Egy $A$ determinisztikus autómata és az N nemdszereminisztikus autómata által elfogadott nyelv ugyanaz, $\alpha(A) = \alpha(N)$.

\Section{Folyamatmodellezés részei}

% NOTE: Ez a rész kissé váratlanul jön, főleg annak tükrében, hogy utána ismét állapotgépes modell következik majd.

\subsection{Érzékenység vizsgálat}

Mi történik, ha rosszul becsljük meg az erőforrásainkat? \\
Mik számítanak lényeges paraméterek? \\
Milyen erőforrásokat bővítsünk? (emberi vagy gépi)? \\
Mi történik, ha a modellparaméterek nem pontosak? becsléshiba , fejlődés

Az érzékenységvizsgálat során az optimális erőforrások paramétereinek a megvizsgálása, hogy azok megváltoztatása milyen hatással lenne az optimális megoldásra.\\
A szerkezet változatlan a marad.

\begin{center}
	Kétféle érzékenységvizsgálatot különböztetünk meg.
\end{center}
1.a jobboldali konstansokra az-az a kapacitásokra vontkozó érzékenység vizsgálat.
2. A $b_{i}$ paraméterek helyett a $b_{i} + \lambda$ szerepel a jobb (kapacitás)oldalon. \\ Az-Az $\lambda$ milyen értékek közé eshet?
Mennyivel tudjuk csökkenteni bizonyos erőforrásokat és mit érünk el vele?
Fontos  a célfüggvény együtthatók érzékenységi vizsgálata. \\
\begin{center}
	Egy álltalános képet, az n.-ik erőforrás vizsgálatához.
\end{center}
\begin{equation}
	\vec{b}+ \lambda \vec{u}_{n} \geq 0
\end{equation}

Érdemes mindíg azt növelni, ahol az árnyékár magasabb lehet, esetünk azt, ahol a legjelentősebb erőforrás növekedést tudjuk elérni.

\subsection{Mennyiségi analízis}

Mennyi eset dolgozható fel egy órán belül? \\
Mennyi extra erőforrásra van szükség? \\
Mennyi az átlagos befejezési idő az egyes eseteknél?  \\
Alternatív megvalósítások esetén melyik modell képes azonos idő alatt több eset kezelésére rövidebb idő alatt feldolgozni egy esetet kisebb várakozási időket generálni ? \\

\subsection{Logikai Analízis}

Történhet e deadlock a rendszerben?  \\
Konkrét eset kezelhető-e sikeresen \\
A folyamat végrehajtása során, minden eset végrehajtódik helyesen, és a végén terminál. \\
Van e lehetőség két feladat tetszőleges sorrendben való végrehajtására.

\subsection{Valószínűségi modell}

A folyamat során bizonyos lépéseknél, elemzéseket végezve, az erőforrásokat különféleképpen is feloszthatjuk, hiszen lehet, hogy egy elágazás során az egyik részbe az esetek $90 \% $-ban lép be, így erre a részre nagyobb erőforrást teszünk, mint a maradék $10 \% $ részre.
Az adatokat megvizsgálva következtethetünk, becsülhetünk.
Egy  egy Diszkrét valószínűségi változó lesz, hiszen véges számú adatokat vizsgálunk.
