\Chapter{Véges Determinisztikus autómaták}

\Section{Folyamatok matematikai leírása}

Véges számú állapotból, és egy tranzíciós diagrammból áll, amelynek szakaszait úgynevezett input szimbólumok jellemzik, amelyek ugyanabból a véges $\Sigma$ ábécéből vannak kiválasztva. 

Két kitüntetett állapot van: A kezdő állapot, jele : $q_{0}$ és a végállapot halmaza, amelynek a jele $F$. (Ezek a \textit{Start} és a \textit{Stop} elemnek tekinthetők egy folyamat modellezése esetén.
A \textit{Start} jelzi a folyamatábrán a \textit{draft} lépést, ahonnan elindul maga az üzleti folyamat. A végső lépés, az utolsó jóváhagyó, \textit{approve} lépés pedig a végállapot, amely megfeltethető az $F$-nek.)

Minden állapotban minden egyes bemeneti szimbólumhoz pontosan egy következő állapot tartozik. Diagram esetében pontosan ezek az állapotok közötti nyilak.

\Section{Formális definíció}

Egy véges determinisztikus autómatát a következőképpen definiálunk.
Legyen $A = (Q, \Sigma, \rho, q_{0}, F)$, ahol $Q$ az állapotok halmaza, $\Sigma$ a véges ábécé, $\Sigma \notin \emptyset$, továbbá $\rho$ a tranzíciós függvény, a  $q_{0}$ a kezdő állapot, $q_{0} \in Q $  $F$ a végállapot.

Könnyen belátható, hogy $F \in Q$ illetve $F \notin \emptyset$.

A matematikai modell pontosan megfeleltethető annak, hogy egy folyamat esetén melyik lépésben milyen input adatokat ad meg a felhasználó, mert a következő lépés ezen adatok alapján változik. Például, egy konkrét esetben, ha a felhasználó 300'000 Ft-ot állít be egy becsült költségnek, akkor oda egy igazgatói jóváhagyás szükséges, ellenkező eseben ez a lépés kihagyható. Az ilyen elágazásokat, és ciklusokat követően jutunk el a (modellben $F$-el jelölt) végállapotba.

\Section{Egyszerű átmeneti rendszerek}

A folyamatok egy másik reprezentálási módját adják az átmeneti rendszerek [].
Legyen $A = (S, T, \alpha, \beta)$, ahol
\begin{itemize}
	\item $S$: az állapotok véges, vagy végtelen halmaza,
	\item $T$: az átmentek véges, vagy végtelen halmaza,
	\item $\alpha, \beta$: $T \rightarrow S$ leképzés $\forall t \in T$-re, amelyben $\alpha(t)$ az átmenet kezdőpontja, $\beta(t)$ pedig a végpontja.
\end{itemize}

A modell ebben az esetben is egy irányított gráf, ahol a csúcsok állapotokat reprezentálnak, az élek pedig átmeneteket.

\begin{figure}[h!]
	\centering
	\includegraphics[width=6.8truecm, height=6.8truecm]{images/AllapotAtmenet.png}
	\caption{A 3.lépésben járó üzleti folyamat}
	\label{fig:Maintance_Process.png}
\end{figure}

Látható, hogy az elvégzett lépéseket zölddel, az aktuális lépést pedig pirossal jelzi a rendszer. \\
$S:{\{\text Draft,Supervisor Approve, Maintance Coordinator Approve, Mechanical Maintance, \\ Maintance Planning, Maintance Coordinator 2\}}$


% TODO: Megnézni, hogy a következő kommentezett rész milyen formában kerül további felhasználásra! (Csak akkor kell bele, hogy ha később lesz valamilyen jelentősége.) (Erre nincs szükség, mivel nem térek ki sehol utak konkatenációjára.)
% Az $A=(S,T,\alpha,\beta)$ átmeneti rendszerben $n>0$ hosszú útnak nevezünk egy olyan $t_{1},t_{2},\dots,t_{n}$ sorozatot, ha $\beta(t_{i}) = \alpha(t_{i+1})$ teljesül $\forall i\in \{ 1,\dots ,  n-1 \}$-re. \\
% Utak konkatenációja, vagy összefűzése $c * c' = t_{1}t_{2}\dots t_{n} g_{1}\dots $ \\

Jó példa egy egyszerű átmeneti rendszer egy italautómata, amelybe egy rögzített összeget dobva két gombot nyomhat meg a felhasználó.

% TODO: Nem teljesen látszik az FSA-val való kapcsolat.

\Section{A Struktúrált programgráf és a nem determinisztikus autómata}

% TODO: Ez a szakasz nem biztos, hogy kell bele, csak ha ugyanezen jelölések szerepelnek majd később is, illetve, hogy ha a program valódiságát validálni lehet. (Csináltam a két modelezett folyamathoz ilyen fajta jelölést.)

A struktúrált programozás olyan programozási elvek összessége, amelyek segítenek
megteremteni, hogy a program szövegszerkezete tükrözze a program végrehajtása
során követett vezérlési folyamatot.


A struktúrált programozás $3$ alapvető elemekből épül fel : Szekvencia , Ciklus , Elágazás . \\

Használt jelölés a szekvenciára : S(tevékenység1, tevékenység2 , $\dots$  , tevékenységn)\\
Ciklus formátuma : C(prédukátum, ciklusmag)\\
Az elágazásra : E(prédukátum,p,q)\\
Fontos jellemzőjük, hogy, minden építőelemnek csak egy belépési és egy kilépési pontja van.
A belépési pont a struktúa elején, a kilépés a végén van.
\\
\begin{center}
	Egy programot valódi programnak nevezünk, ha:
\end{center}

1. programgráfja véges számú nem zérus bemenő éllel és kimenő éllel rendelkezik, \\
2. programgráfjának csomópontjai predikátumok, függvények és gyűjtők, \\
3. programgráfjának minden csomópontján keresztül vezet legalább egy útvonal, \\
amely egy bemenő éllel és egy kimenő éllel rendelkezik ( a programgráf kezdő élétől \\
a kilépési élig vezet).

\Section{Üzleti folyamatokhoz tartozó folyamatábrák}

\begin{figure}[h!]
\centering
\includegraphics[width=6.8truecm, height=6.8truecm]{images/Demand_Process.png}
\caption{Road Transportation Demand}
\label{fig:Demand_Process}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=6.8truecm, height=6.8truecm]{images/Maintance_Process.png}
\caption{Road Transportation Maintance}
\label{fig:Maintance_Process.png}
\end{figure}






\Section{Folyamat megtervezése}

A folyamat tervezésénél fontos szerepe van a strukturáltságnak, ellenkező esetben nagy problémák is adódhatnak, mint egy  végtelen ciklus, esetleg több input bemenet.
\begin{itemize}
	\item Az első azért okozna problémát, mert a folyamat sosem érne véget, nem lenne befejezve.
	\item Ha több input bemenet lenne (több különböző draft page), egy folyamaton belül,  akkor az már egy más folyamathoz tartoznak, egy más igényléshez.
\end{itemize}

A nagyobb és komplexebb folyamatokat, kisebb részekre is bonthatjuk, amelyre csak struktúrált programként van lehetőségünk megadni. Ezt az eljárást
a vezérlőgráf lebontásának nevezzük.

% TODO: A következő rész akkor lehet érdekes, hogy ha egy gráf validátort össze sikerül hozzá rakni.

Lépései:  a struktúrált alapszerkezetek valamelyikét egy függvény csomóponttal helyettesítjük, és ezt mindaddig folytatjuk, amíg ez lehetséges. Az egyetlen csomópontból álló gráfot egyetlen
éllel helyettesítjük.

Megjegyzés:
minden nem strukturált program átírható vele ekvivals strukturált program formályában. \\
Áttérésként a Véges Determinisztikus autómatákra, egy $a\in \Sigma$ betűhöz, és $q_{i}$ állapothoz, pontosan egy output (nyíl) tarotzik. \\
% TODO: Ennél a Böhm-Jacopini tételt lehet hivatkozni. (Így emlékszem, a jegyzetet nem találom)
Minden valódi program átalakítható vele ekvivalens strukturált program formájába.

A Road Transportation Maintance folyamathoz tartozó jelölés a 3 alapvető elem segítségével :
\vskip 0.3 true cm
{\bf S(Start,Draft, E(Approve; Stop; S(Supervisor,maintance, \\ E(ProblemType;S(Maintance planning); S(Mechanical))), Maintance Coordinator 2));}


Látható, hogy a start lépés után a szekvenciában a draft lépés következik, így ezzel a felírással strukturált lesz a folyamatábra.\\
Hasonlóképpen a Road Transportation Demand is felírható az alábbi módon : \\
{\bf S(Start,Draft,E(Approve;S(Manager approve,RoadTransp Ort Approve; Stop)),\\ Stop)
}

\Section{Nem determinisztikus autómata}

(Nondeterminisztic Finite Automation) NFA esetén, viszon egy adott $q_{i}$ állapothoz és egy $a\in \Sigma$ jelhez több output is tartozhat, vagy egy sem.
\vskip 0.3 true cm
Tehát lehetséges olyan belső állapota, amiből a beolvasott szimbólum hatására több lehetséges állapot egyikébe mehet át.\\
Láthatjuk , hogy a véges állapotú autómaták megfeleltethetőek a modellezett folyamatoknak.
Egy strukturálatlan alapelemekből felépülő folyamat, megfelel egy Non determinisztikus autómatának.
A struktúrált elemekből felépülő modellezés pedig egy véges állapotú, determinisztikus autómatával.

Mint ahogy a Struktúrált programozánál is említettük, hogy bármely nem struktúrált program átírható, vele ekvivalens struktúrált programmá, ez szintén jellemző a véges állapotú, nondetermenisztikus autómatákra.
Ezt a tranzíciós függvény elkészítésével tudjuk megoldani, amelyben minden olyan állapot, ahonnan egy bizonyos beolvasott szóval több helyre tudunk eljutni, egy új állapotként felvesszük, majd rekurzívan tovább vizsgáljuk.



\Section{DFA és NFA ekvivalenciája}

Legyen adott egy $N = (Q, \Sigma, \rho, q_{0}, F) $ véges nondeterminisztikus autómata. Nyelve legyen $\alpha(n)$. $n$-ből kiindulva szerkezhetünk egy olyan A véges determinisztikus autómatát, amely ugyanazt az $\alpha(n)$ nyelvet fogadja el.\\
\begin{equation}
	A=(P(q),\Sigma,\rho^{'},[q_{0}],F' )
\end{equation}
Ahol Q a részhalmazok összessége, F' pedig a Q mindazon részhalmazai, amelyek legalább egy F beli állapotot tartalmaznak. (Végállapothoz vezetnek)

\begin{align*}
	&& \rho'  \text{ így értelmezhetünk, minden } a\in\Sigma \\
	&&  \rho'([q_{1},q_{2},\dots,q_{n}],a) = \rho(q_{1},a) \cup \rho(q_{2},a) \cup \dots \cup \rho(q_{k},a)
\end{align*}

Egy $A$ determinisztikus autómata és az N nemdszereminisztikus autómata által elfogadott nyelv ugyanaz, $\alpha(A) = \alpha(N)$.

\Section{Folyamatmodellezés}

A modell, a való világ egy részének egyszerűsített példánya.

% TODO: Hogy ha a modellről ilyen formában szó esik, akkor azt érdemes korábban megtenni. (Előrébb hoztam, a második részhez.)

A modellezés célja az, hogy felmérjük, majd  elemezhessük és javíthassuk a
folyamatainkat.Esetünkben azt célszerű vizsgálni, milyen jóváhagyási lépések szükségesek , és melyek azok amelyek elhagyhatóak, redundánsak. Az elmezés során több szempontot érdemes szemügyre venni. Például felhasználók kérését, az erőforrások kezelését.  A folyamatmodellek különböző információkat hordozhatnak és változó lehet a befogadó fél is, így nem mindegy, hogy milyen szemszögéből nézve készítjük el őket. Tehát a különböző nagy részlegeknek más-más célja lesz az adott folyamattal, különböző megjelenési formákat kell biztosítani, más változókkal, mezőkkel , adatbázissal, és erőforásokkal. A folyamatmodellek alapvetően két csoportra bonthatóak. Léteznek As-Is
modellek, amik a jelenlegi helyzetet mutatják be, és To-Be modellek, amik a kívánt
szituáció ábrázolását takarják.  \\
A folyamatok leírására több lehetőség van. Legtöbbször ezek
kombinációját használják a felelős személyek, ahelyett, hogy egyetlen egyhez
ragaszkodnának. Készülhet szöveges folyamatleírás vagy táblázatos leírás is, de a
legcélravezetőbb a grafikus, modell-orientált leírás, amely segítségével sokkal
egyértelműbben, és átláthatóbban ábrázolhatjuk az adott folyamatokat. A Bpm rendszer grafikus ábrázolást használ, hiszen folyamatábrákat használ, a jó áttekinthetőség érdekében. \\

Több különböző szoftvert vehetünk igénybe a grafikus ábrázolás elkészítéséhez, amelyek megkönnyítik az elkészítést, de ebből adódóan egy hátrányt is
magában hordoz a módszer, mégpedig azt, hogy a többféle ábrázolási módból adódóan,
nehezen értelmezhető modellek jöhetnek létre. Ennek kiküszöbölésére azonban már
bevezetésre kerültek olyan modellező nyelvek, szoftverek, melyek egységesítik az
ábrázolás módját, ilyenek például az UML szabvány.
Az UML szabványos,  általános célú modellező nyelv, üzleti elemzők, rendszertervezők, szoftvermérnökök számára.
Jelentése:  (Unified Modeling Language)
Segítségével tervezni  illetve dokumentálni lehet a szoftvereket. Az UML-ben modellek és diagramok adhatók meg, különböző nézetekben.
Az üzleti feladatok nem csupán a szereplőkkel lehetnek kapcsolatban, hanem más feladatokkal is kapcsolatban állhatnak. Gyakran állnak elő összefüggések különféle üzleti részfolyamatok illetve használati esetek között. Az UML két lehetséges függőségi kapcsolatot definiál a használati esetek között, ezek a beillesztés és a kiterjesztés.
Az UML a jelöléseknek gazdag választékát kínálja, mely segítségével a szoftverfejlesztés összesfázisamodellezhető. \\

Az üzleti folyamatok modellezésével az üzleti stratégia és az informatikai
rendszerek között olyan kapcsolat hozható létre, ami nagyban hozzájárulhat üzleti
értékünk növeléséhez.

\Section{Folyamatmodellezés részei}

% NOTE: Ez a rész kissé váratlanul jön, főleg annak tükrében, hogy utána ismét állapotgépes modell következik majd.

\subsection{Érzékenység vizsgálat}

Mi történik, ha rosszul becsljük meg az erőforrásainkat? \\
Mik számítanak lényeges paraméterek? \\
Milyen erőforrásokat bővítsünk? (emberi vagy gépi)? \\
Mi történik, ha a modellparaméterek nem pontosak? becsléshiba , fejlődés

Az érzékenységvizsgálat során az optimális erőforrások paramétereinek a megvizsgálása, hogy azok megváltoztatása milyen hatással lenne az optimális megoldásra.\\
A szerkezet változatlan a marad.

\begin{center}
	Kétféle érzékenységvizsgálatot különböztetünk meg.
\end{center}
1.a jobboldali konstansokra az-az a kapacitásokra vontkozó érzékenység vizsgálat.
2. A $b_{i}$ paraméterek helyett a $b_{i} + \lambda$ szerepel a jobb (kapacitás)oldalon. \\ Az-Az $\lambda$ milyen értékek közé eshet?
Mennyivel tudjuk csökkenteni bizonyos erőforrásokat és mit érünk el vele?
Fontos  a célfüggvény együtthatók érzékenységi vizsgálata. \\
\begin{center}
	Egy álltalános képet, az n.-ik erőforrás vizsgálatához.
\end{center}
\begin{equation}
	\vec{b}+ \lambda \vec{u}_{n} \geq 0
\end{equation}

Érdemes mindíg azt növelni, ahol az árnyékár magasabb lehet, esetünk azt, ahol a legjelentősebb erőforrás növekedést tudjuk elérni.

\subsection{Mennyiségi analízis}

Mennyi eset dolgozható fel egy órán belül? \\
Mennyi extra erőforrásra van szükség? \\
Mennyi az átlagos befejezési idő az egyes eseteknél?  \\
Alternatív megvalósítások esetén melyik modell képes azonos idő alatt több eset kezelésére rövidebb idő alatt feldolgozni egy esetet kisebb várakozási időket generálni ? \\

\subsection{Logikai Analízis}

Történhet e deadlock a rendszerben?  \\
Konkrét eset kezelhető-e sikeresen \\
A folyamat végrehajtása során, minden eset végrehajtódik helyesen, és a végén terminál. \\
Van e lehetőség két feladat tetszőleges sorrendben való végrehajtására.

\subsection{Valószínűségi modell}

A folyamat során bizonyos lépéseknél, elemzéseket végezve, az erőforrásokat különféleképpen is feloszthatjuk, hiszen lehet, hogy egy elágazás során az egyik részbe az esetek $90 \% $-ban lép be, így erre a részre nagyobb erőforrást teszünk, mint a maradék $10 \% $ részre.
Az adatokat megvizsgálva következtethetünk, becsülhetünk.
Egy  egy Diszkrét valószínűségi változó lesz, hiszen véges számú adatokat vizsgálunk.
